[{"title":"用typescript实现依赖注入模式","url":"/2022/04/03/Coding/dependency-injection-ts/","content":"用 typescript 实现依赖注入模式本篇文章将介绍如何使用 typescript 来实现依赖注入功能，并考虑到各种情况，包括实现单例和处理循环依赖等\n概念依赖注入的概念非常简单。它基于一个容器（Container），用于管理对象的创建和解决依赖关系。在使用依赖注入之前，我们需要定义一些“可注入”的类（Injectable），并使用“Inject”标记它们的依赖关系。现在，让我们来逐步实现这个过程。\n实现Step.1: 创建 @injectable 装饰器@injectable 可以将一个类标记为一个可注入类, 可以使用 reflect-metadata 库来实现这个装饰器\n首先, 安装 reflect-metadata 库\nnpm i reflect-metadata\n\n之后在引入这个库并定义 injectable 函数\nimport &quot;reflect-metadata&quot;;export function Injectable() &#123;  return function (taget: any) &#123;    Reflect.defineMetadata(&quot;injectable&quot;, true, target);  &#125;;&#125;\n\n这个装饰器使用 Reflect.defineMetadata 为被装饰的类添加了一个 injectable 的元数据标识\nstep.2: 创建 @inject 装饰器@inject 装饰器用于标记类的依赖关系\nimport &quot;reflect-metadata&quot;;export function Inject() &#123;  return function (target: any, propertyKey: string) &#123;    const type = Reflect.getMetadata(&quot;design:type&quot;, target, propertyKey);    Reflect.defineMetadata(&quot;inject&quot;, type, target, propertyKey);  &#125;;&#125;\n\n这个装饰器使用 Reflect.getMetadata 获取标记属性的类型, 随后用 Reflect.defineMetadata 将类型信息储存到元数据中\nstep.3: 实现容器类容器类 Container 用于管理类的实例的创建和解决依赖关系, 需要支持以下功能:\n\n注册标记为 @injectable 的类\n处理依赖关系\n创建单例\n解决循环依赖\n\nimport &quot;reflect-metadata&quot;;class Container &#123;  private instances: Map&lt;Constructor, any&gt; = new Map(); // 单例  private resolvingQueue: Set&lt;Constructor&gt; = new Set(); // 解析队列  register&lt;T&gt;(cls: Constructor&lt;T&gt;) &#123;    const injectable = Reflect.getMetadata(&quot;injectable&quot;, cls);    if (!injectable) &#123;      throw new Error(`Class $&#123;cls.name&#125; is not marked with @injectable`);    &#125;    this.instances.set(cls, null);  &#125;  resolve&lt;T&gt;(cls: Constructor&lt;T&gt;): T &#123;    if (this.resolvingQueue.has(cls)) &#123;      // 当解析队列中包含这个类时, 表示出现循环依赖, 抛出错误      throw new Error(`Circular dependency detected for class $&#123;cls.name&#125;`);    &#125;    const instance = this.instances.get(cls);    if (instance !== null) &#123;      // 当存在已解析的实例时, 则返回该实例, 实现单例模式      return instance;    &#125;    this.resolvingQueue.add(cls);    const injectParams = Reflect.getMetadata(&quot;design:paramtypes&quot;, cls) || []; // 获取构造函数的参数类型列表    const resolvedParams = injectParams.map((param) =&gt; this.resolve(param)); // 递归获取参数类的单例    const newInstance = new cls(...resolvedParams);    this.instances.set(cls, newInstance);    this.resolvingQueue.delete(cls);    return newInstance;  &#125;&#125;\n\n这个 Container 类有两个主要方法: register 用于注册可注入的类, resolve 用于处理依赖关系, 并且维护单例和检查循环依赖\n示例将我们的依赖注入模块作为一个库引入, 来写一个简单示例\nimport &#123; Injectable, Inject, Container &#125; from &quot;my-di-lib&quot;;@Injectable()class Foo &#123;  constructor(@Inject() public bar: Bar) &#123;&#125;&#125;@Injectable()class Bar &#123;&#125;const container = new Container();container.register(Foo);container.register(Bar);const foo = container.resolve(Foo);foo instanceof Foo; // truefoo.bar instanceof Bar; // true\n","categories":["Coding"],"tags":["Typescript","依赖注入","单例模式","设计模式"]},{"title":"ES6+ 知识点整理","url":"/2022/06/01/Coding/es-features-summary/","content":"ES6+ 知识点整理介绍 ES6 及以上版本的新特性等知识点的整理笔记\nPromise通过 new Promise(function) 创建 promise 对象时必须传回调函数, 否则会报错\nPromise 三种状态\npending 初始状态, 处理中状态\nfulfilled 被解决状态, 调用 then 回调函数\nrejected 被拒绝状态, 调用 catch 回调函数\n\nPromise 静态方法\nPromise.all 将多个 Promise 包装成一个, 若全部 fulfilled 则 resolve 所有 Promise, 若有一个失败则 reject\nPromise.race 将多个 Promise 包装成一个, 若有一个 resolve 或 reject 则返回最快完成的那个 promise 实例\nPromise.allSettled 将多个 Promise 包装成一个, 等所有 Promise 实例的状态都发生变更就执行 resolve, 无论这些 promise 的状态是成功还是失败\nPromise.any 将多个 Promise 包装成一个, 若有一个 resolve 则返回最快完成的那个 promise 实例, 若所有都失败则 reject\nPromise.resolve\nPromise.reject\n\nPromise 和 async awaitAsync 是一个函数关键字, 声明一个函数是异步函数, 将返回一个 Promise 对象\nAwait 是一个运算符, 只能用于 async 函数中(也可以在代码顶层使用), 用于等待一个异步解析, 并返回解析完成后的值, 会暂停 async 函数的执行, 直到异步解析完毕后再执行后续代码\nPromise 和 async&#x2F;await 的使用场景:\n\n如果有很多连续的依赖于前一个异步操作结果的异步操作, 则可以使用 async&#x2F;await, 这样更接近同步代码, 避免回调地狱\n如果需要执行多个并行的异步操作并在全部处理完后再处理结果, 则 Promise 更合适\n\nSymbol新的数据类型, 声明一个不可重复的值, 在对象中可通过 Object.getOwnPropertySymbols 或 Reflect.ownKeys 遍历出来\n若想得到两个相等的 Symbol 则需要用 Symbol.for(key)\nvar s1 = Symbol.for(&quot;123&quot;);var s2 = Symbol.for(&quot;123&quot;);s1 === s2; // true\n\nvar, let, const\nvar 定义在函数内则作用域仅在函数内, 若定义在函数外(包括 if 或 for 等代码块内), 则是全局作用域, 而 let 和 const 是块作用域\nvar 变量可以在其作用域内更新和重新声明；let 变量可以更新但不能重新声明；const 变量既不能更新也不能重新声明\n它们都被提升到了作用域的顶部, 但是, var 变量是用 undefined 初始化的, 而 let 和 const 变量不会被初始化\nvar 和 let 可以在不初始化的情况下声明, 而 const 必须在声明时初始化\n\nSet 和 MapSet 是由一组无序且唯一(即不能重复)的项组成的, 可以想象成集合是一个既没有重复元素, 也没有顺序概念的数组\nMap 类似于对象, 也是键值对的集合, 但是“键”的范围不限于字符串, 各种类型的值(包括对象)都可以当作键, 是一种更完善的 Hash 结构实现. 如果你需要“键值对”的数据结构, Map 比 Object 更合适\n共同点: 集合, 字典可以存储不重复的值不同点: 集合是以[值, 值]的形式存储元素, 字典是以[键, 值]的形式存储\nProxy可以给目标对象定义一个关联的代理对象, 而这个代理对象可以作为抽象的目标对象来使用, 在对目标对象的各种操作影响目标对象之前, 可以在代理对象中对这些操作加以控制. 代理对象可以作为目标对象的替身, 但又完全独立于目标对象\n动态导入和顶层 awaitES2020 原生支持模块导入, 导入的模块不会污染全局命名空间\nif (conditon) &#123;  const module = await import(&quot;./myModule.js&quot;);&#125;\n\n并且现在可以在顶级作用域中直接使用 await\n空值合并?? 运算符判断变量为 null 或 undefined\nglobalThis不论在什么环境下, globalThis 始终引用全局对象, 在浏览器是 window, 在 nodejs 是 global, 在 web worker 是 self\nClass Fields类中使用#开头可以声明 private 成员, 使用 static 可以声明静态成员, 同时可以在类中用 in 关键字判断实例中是否有私有字段\nclass Person &#123;  #age = 50;  name = &quot;King&quot;;  static gender = &quot;male&quot;;  static isPrivate(obj) &#123;    console.log(#age in obj);  &#125;&#125;const person = new Person();person.name; // Kingperson.#age; // Uncaught SyntaxError: Private field &#x27;#age&#x27; must be declared in an enclosing classperson.gender; // undefinedPerson.gender; // malePerson.isPrivate(person); // true\n\nBigIntJS 只能安全的表示-(2^53-1)至 2^53-1 范的值, 即 -9007199254740991 到 9007199254740991, 引入 BigInt 后可以在数字末尾加 n,表示更大的数字\n9007199254740991n + 1000n; // 9007199254741991n// 但不能混用BigInt和number类型9007199254740991n + 1000; // Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions\n","categories":["Coding"],"tags":["ES6","ES2020","EcmaScript"]},{"title":"ES6 Proxy 对象特性和存在的缺陷","url":"/2022/04/24/Coding/flaws-of-js-proxy/","content":"ES6 Proxy 对象特性和存在的缺陷详细介绍 ES6 中新加入的 Proxy 对象的特性和在使用中存在的缺陷\nProxy 实例首先看看 Proxy 是如何代理一个对象的\nclass Person &#123;  constructor(first, last) &#123;    this.firstName = first;    this.lastName = last;  &#125;  get fullName() &#123;    return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`;  &#125;  introduce(other = &quot;friend&quot;) &#123;    console.log(`Hello $&#123;other&#125;, my name is $&#123;this.fullName&#125;!`);  &#125;&#125;const leo = new Person(&quot;Leo&quot;, &quot;Messi&quot;);const proxy = new Proxy(leo, &#123;  get(target, prop) &#123;    console.log(`Access: $&#123;prop&#125;`);    return Reflect.get(target, prop);  &#125;,&#125;);proxy.introduce();\n\n上面的代码实例化了一个 Proxy 对象, 传递一个 Person 对象来作为被代理的对象, 这时, 调用 proxy 的 get 方法要做两件事:\n\n将正在检索的对象键打印出来\n使用 Reflect.get 将属性值从实例化的 Person 对象中取出来\n\n上面的打印结果是:\nAccess: introduceAccess: fullNameHello friend, my name is Leo Messi!\n\n\n在 js 的对象中,调用一个方法时, 必然先调用对象上的 get 方法, 所以第一条打印信息是 introduce\n此时, introduce 方法中的 this 指向 proxy 对象, 所以调用 this.fullName 会再次调用 proxy 的 get 方法打印第二条信息\n最后打印 introduce 方法的返回值\n\n但为什么没有打印 firstName 和 lastName 呢, 当访问 fullName 时内部确实也访问了这两个变量的\n在我们使用 Reflect.get 访问内部的 fullName 时, 因为 fullName 是一个属性, 它会调用属性描述符上的 get 方法, 此时的 this 在运行时已经指向了 target, 而 target 不是 proxy, 不会触发 proxy 中定义的 get 方法\n为了完成 person 对象的全面代理, 则需要设置 Reflect 的第三个参数:\n...const proxy = new Proxy(leo, &#123;  get(target, prop, receiver) &#123;    console.log(`Access: $&#123;prop&#125;`);    return Reflect.get(target, prop, receiver);  &#125;,&#125;);proxy.introduce();\n\n这个操作会将使用 Reflect.get 获取 taget 内部属性的 this 也指向调用者, 而调用者则是 proxy\n打印结果如下:\nAccess: introduceAccess: fullNameAccess: firstNameAccess: lastNameHello friend, my name is Leo Messi!\n\nProxy 撤销通过 Proxy.revocable 方法创建的代理对象是可撤销代理的对象, 这种代理可以被创建者禁用, 下面是一个示例:\n...const &#123; proxy, revoke &#125; = Proxy.revocable(leo, &#123;  get(target, prop, receiver) &#123;    console.log(`Access: $&#123;prop&#125;`);    return Reflect.get(target, prop, receiver);  &#125;,&#125;);proxy.introduce();revoke()proxy.introduce(&quot;boy&quot;);\n\n其结果为:\nAccess: introduceAccess: fullNameAccess: firstNameAccess: lastNameHello friend, my name is Leo Messi!Uncaught TypeError: Cannot perform &#x27;get&#x27; on a proxy that has been revoked\n\nProxy.revocable 会返回一个 revoke 方法, 调用后就可以撤销代理\nProxy 的缺陷兼容性作为 ES6 的特性, Proxy 对于旧版浏览器支持不好, 即使使用 proxy-polyfill 也仅能部分支持 Proxy 的功能\n在 github 上的 GoogleChrome&#x2F;proxy-polyfill 库目前只支持以下 traps:\n\nget\nset\napply\nconstructor\n\n性能Proxy 的性能比 Promise 还差, 也差于 Object.defineProperty\n不能安全代理私有成员修改之前的例子:\nclass Person &#123;  #firstName;  #lastName;  constructor(first, last) &#123;    this.#firstName = first;    this.#lastName = last;  &#125;  get firstName() &#123;    return this.#firstName;  &#125;  get lastName() &#123;    return this.#lastName;  &#125;  get fullName() &#123;    return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`;  &#125;  introduce(other = &quot;friend&quot;) &#123;    console.log(`Hello $&#123;other&#125;, my name is $&#123;this.fullName&#125;!`);  &#125;&#125;const leo = new Person(&quot;Leo&quot;, &quot;Messi&quot;);const proxy = new Proxy(leo, &#123;  get(target, prop) &#123;    console.log(`Access: $&#123;prop&#125;`);    return Reflect.get(target, prop);  &#125;,&#125;);proxy.introduce();\n\n现在看看打印结果:\nAccess: introduceAccess: fullNameHello friend, my name is Leo Messi!\n\n貌似没有问题, 但如果给 Reflect 传入第三个参数, 则会出现问题:\n...const proxy = new Proxy(leo, &#123;  get(target, prop, receiver) &#123;    console.log(`Access: $&#123;prop&#125;`);    return Reflect.get(target, prop, receiver);  &#125;,&#125;);proxy.introduce();\n\n打印结果为:\nAccess: introduceAccess: fullNameAccess: firstNameUncaught TypeError: Cannot read private member #firstName from an object whose class did not declare it\n\n可以看到, 但传递 receiver 时, 调用 firstName 时 this 会指向 proxy, 而这个调用这个属性的 getter 时会指向一个私有变量, 私有变量不能在对象外获取, 则会出现这个问题\n如果方法中使用了私有成员, 如:\n...  introduce(other = &quot;friend&quot;) &#123;    console.log(`Hello $&#123;other&#125;, my name is $&#123;this.#firstName&#125; $&#123;this.#lastName&#125;!`);  &#125;\n\n则可以在 Proxy 的 getter 中再次改变 this 指向来用原有对象调用该方法:\n...const proxy = new Proxy(leo, &#123;  get(target, prop, receiver) &#123;    console.log(`Access: $&#123;prop&#125;`);    const value = Reflect.get(target, prop, receiver);    return typeof value === &#x27;function&#x27; ? value.bind(target) : value  &#125;,&#125;);proxy.introduce();\n\n打印结果为:\nAccess: introduceHello friend, my name is Leo Messi!\n\n这样就能在调用使用了私有成员的方法时获取到正确的结果了\n","categories":["Coding"],"tags":["ES6","Proxy","代理","Proxy缺陷","Reflect"]},{"title":"Nodejs 事件循环","url":"/2022/04/16/Coding/nodejs-event-loop/","content":"Nodejs 事件循环详细介绍 Nodejs 中的 事件循环机制\n事件循环经典题目async function async1() &#123;  console.log(&quot;async1 start&quot;);  await async2();  console.log(&quot;async1 end&quot;);&#125;async function async2() &#123;  console.log(&quot;async2&quot;);&#125;console.log(&quot;script start&quot;);setTimeout(function () &#123;  console.log(&quot;setTimeout0&quot;);&#125;, 0);setTimeout(function () &#123;  console.log(&quot;setTimeout3&quot;);&#125;, 3);setImmediate(() =&gt; console.log(&quot;setImmediate&quot;));process.nextTick(() =&gt; console.log(&quot;nextTick&quot;));async1();new Promise(function (resolve) &#123;  console.log(&quot;promise1&quot;);  resolve();  console.log(&quot;promise2&quot;);&#125;).then(function () &#123;  console.log(&quot;promise3&quot;);&#125;);console.log(&quot;script end&quot;);\n\n该题目涉及 Nodejs 中所有事件循环相关概念, 弄清楚这个顺序则对于 Nodejs 的事件循环机制就有一个清晰的了解了, 这段代码的输出结果为:\nscript startasync1 startasync2promise1promise2script endnextTickasync1 endpromise3setTimeout0setImmediatesetTimeout3\n\n异步任务异步任务有两种:\n\n追加在本轮循环的异步任务\n追加在次轮循环的异步任务\n\n本轮循环一定早于次轮循环执行\nNodejs 规定 process.nextTick 和 promise 的回调函数追加在本轮循环, 同步任务执行完毕后就会开始执行他们, 而 setTimeout, setInterval 和 setImmediate 等 timers 的回调函数则追加到次轮循环\nprocess.nextTick()Nodejs 执行完所有同步任务, 接下来就会执行 process.nextTick 的任务队列, 属于本轮循环\n微任务(microtask)promise 的回调函数会进入异步任务里的微任务队列\n微任务队列追加在 process.nextTick 之后, 也属于本轮循环\nPromise.resolve().then(() =&gt; console.log(1));process.nextTick(() =&gt; console.log(2));\n\n以上代码始终先输出 2 再输出 1\nprocess.nextTick(() =&gt; console.log(1));Promise.resolve().then(() =&gt; console.log(2));process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4));\n\n输出结果 1, 3, 2, 4\n开启 process.nextTick 任务会直接进入 nextTickQueue 中, 开启 promise 回调任务会直接进入 microTaskQueue 中, 只有前一个队列清空后才会执行下一个队列\nasync 和 promiseasync 函数返回一个 promise 对象, 当函数执行时是作为一个同步函数执行, 直到遇到 await, 就会先返回, 等到执行微任务阶段完成这个异步任务, 再执行函数体内后续操作\n而在 promise 本身函数体中的代码在 resolve 之后依然可以执行, 因为在 then 回调之前, 该函数体内还是属于同步任务阶段, 正规的写法应该不要在 resolve 或 reject 后执行任何操作\n事件循环阶段\ntimers 阶段\n\n\n此阶段包括 setTimeout 和 setInterval\n\n\nIO callbacks\n\n\n大部分回调事件, 普通的 callback\n\n\npoll 阶段\n\n\n网络连接, 读取文件等操作\n\n\ncheck 阶段\n\n\nsetImmediate\n\n\nclose 阶段\n\n\n一些 close 回调, 如 socket.on(‘close’, …) 等\n\n开启事件循环Nodejs 开始执行脚本时, 会先进行事件循环初始化, 此时还没有开始事件循环, 会优先处理以下任务:\n\n同步任务\n发出异步请求\n规划定时器生效时间\n执行 process.nextTick 回调\n开始事件循环\n\nsetTimeout 和 setImmediate由于 setTimeout 属于 timers 阶段, setImmediate 属于 check 阶段, 所以 setTimeout 始终早于 setImmediate 执行\nsetTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2));\n\n理论上, 这段代码会先输出 1 再输出 2, 但有时也会先输出 2 再输出 1\n因为 setTimeout 第二个参数缺省值为 0, 但 Nodejs 做不到 0 毫秒执行回调函数, 至少也要 1 毫秒, 所以 setTimeout(…, 0) 等于 setTimeout(…, 1)\n基于系统当前状态, 进入事件循环时可能不到 1 毫秒也可能超过 1 毫秒, 如果不到 1 毫秒, 则会先进入 check 阶段, 就会先执行 setImmediate 回调函数\n但是如果在 I&#x2F;O callbacks 阶段执行上述代码, 则会先执行 check 再执行 timers\nconst fs = require(&quot;fs&quot;);fs.readFile(&quot;aaa.json&quot;, () =&gt; &#123;  setTimeout(() =&gt; console.log(1));  setImmediate(() =&gt; console.log(2));&#125;);\n\n上述代码必然先输出 2 再输出 1\n","categories":["Web"],"tags":["Nodejs","事件循环","微任务","定时器"]},{"title":"Rust中使用Serde进行序列化和反序列化","url":"/2022/06/03/Coding/rust-serde-tutorial/","content":"Rust 中使用 Serde 进行序列化和反序列化在 rust 中使用 serde 进行 json, bson, yaml 等格式的序列化&#x2F;反序列化处理, 并且也可以自定义序列化&#x2F;反序列化的方式\n基础安装使用 Serde 之前需要生命依赖, 在 Cargo.toml 中声明:\n[dependencies]serde = &#123; version = &quot;1.0&quot;, features = [&quot;derive&quot;] &#125;serde_json = &quot;1.0&quot; # 处理json时可以生命 serde_json\n\nfeatures &#x3D; [“derive”]表明使用 Serde 的派生宏来自动生成序列化&#x2F;反序列化代码\n序列化要用 Serde 进行序列化, 需要让 struct 实现 serde::Serialize trait, 如:\n#[derive(Serialize)]struct People &#123;  name: string  age: u32&#125;\n\n然后使用 serde_json 库将 People 序列化为 json 字符串\nuse serde_jsonlet people = People &#123;  name: &quot;Pele&quot;.to_owned(),  age: 84,&#125;;let json = serde_json::to_string(&amp;people).unwrap();println!(&quot;&#123;&#125;&quot;, json); // &#123;&quot;name&quot;:&quot;Pele&quot;,&quot;age&quot;:84&#125;\n\n反序列化要用 Serde 进行反序列化, 需要让 struct 实现 serde::Deserialize trait, 如:\n#[derive(Deserialize, Debug)]struct People &#123;  name: string  age: u32&#125;\n\n然后使用 serde_json 库将 json 字符串反序列化为 People\nuse serde_jsonlet json = r#&quot;&#123;&quot;name&quot;:&quot;Pele&quot;,&quot;age&quot;:84&#125;&quot;#;let people = serde_json::from_str(json).unwrap();println!(&quot;&#123;:?&#125;&quot;, people); // People &#123; name: &quot;Pele&quot;, age: 84 &#125;\n\n进阶自定义Serde 可以自定义序列化&#x2F;反序列化方式, 如将 People 结构体在序列化时 name 值大写, 反序列化时转为小写:\nuse serde::&#123;Serialize, Deserialize, Serializer, Deserializer&#125;;#[derive(Serialize, Deserialize, Debug)]struct People &#123;    #[serde(serialize_with = &quot;serialize_name&quot;, deserialize_with = &quot;deserialize_name&quot;)]    name: String,    age: u32,&#125;fn serialize_name&lt;S&gt;(name: &amp;String, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;where    S: Serializer,&#123;    serializer.serialize_str(&amp;name.to_uppercase())&#125;fn deserialize_name&lt;&#x27;de, D&gt;(deserializer: D) -&gt; Result&lt;String, D::Error&gt;where    D: Deserializer&lt;&#x27;de&gt;,&#123;    let name = String::deserialize(deserializer)?;    Ok(name.to_lowercase())&#125;\n\n在该结构体中, 使用 #[serde(serialize_with &#x3D; “serialize_name”, deserialize_with &#x3D; “deserialize_name”)] 指定了自定义序列化&#x2F;反序列化方式\n枚举Serde 同样支持枚举的序列化&#x2F;反序列化\nuse serde::&#123;Serialize, Deserialize&#125;;#[derive(Serialize, Deserialize, Debug)]#[serde(tag = &quot;type&quot;)]enum People &#123;    American &#123; name: String, age: u32 &#125;,    Japanese &#123; name: String, age: u32 &#125;,&#125;\n\n在处理时, 需要用 #[serde(tag &#x3D; “type”)] 指定枚举类型的标签\nuse serde_json;let american = People::American &#123; name: &quot;Tod&quot;.to_owned(), age: 24 &#125;;let json = serde_json::to_string(&amp;american).unwrap();println!(&quot;&#123;&#125;&quot;, json); // &#123;&quot;type&quot;:&quot;American&quot;,&quot;name&quot;:&quot;Tod&quot;,&quot;age&quot;:24&#125;let json = r#&quot;&#123;&quot;type&quot;:&quot;American&quot;,&quot;name&quot;:&quot;Tod&quot;,&quot;age&quot;:24&#125;&quot;#;let american: People = serde_json::from_str(json).unwrap();println!(&quot;&#123;:?&#125;&quot;, american); // American &#123; name: &quot;Tod&quot;, age: 24 &#125;\n\n结构体中的 OptionSerde 支持序列化&#x2F;反序列化结构体中的 Option 类型, 例如:\nuse serde::&#123;Serialize, Deserialize&#125;;#[derive(Serialize, Deserialize, Debug)]struct People &#123;    #[serde(skip_serializing_if = &quot;Option::is_none&quot;)]    name: Option&lt;String&gt;,    age: u32,&#125;\n\n在处理 Option 类型时, 需要指定 #[serde(skip_serializing_if &#x3D; “Option::is_none”)], 当 Option 值为 None 时, 不进行序列化\nuse serde_json;let animal = Animal &#123; name: Some(&quot;Tod&quot;.to_owned()), age: 3 &#125;;let json = serde_json::to_string(&amp;animal).unwrap();println!(&quot;&#123;&#125;&quot;, json); // &#123;&quot;name&quot;:&quot;Tod&quot;,&quot;age&quot;:3&#125;let animal = Animal &#123; name: None, age: 3 &#125;;let json = serde_json::to_string(&amp;animal).unwrap();println!(&quot;&#123;&#125;&quot;, json); // &#123;&quot;age&quot;:3&#125;let json = r#&quot;&#123;&quot;age&quot;:3&#125;&quot;#;let animal: Animal = serde_json::from_str(json).unwrap();println!(&quot;&#123;:?&#125;&quot;, animal); // Animal &#123; name: None, age: 3 &#125;\n\n结构体中的 VecSerde 支持序列化&#x2F;反序列化结构体中的 Vec 类型, 例如:\nuse serde::&#123;Serialize, Deserialize&#125;;#[derive(Serialize, Deserialize, Debug)]struct Family &#123;  members: Vec&lt;People&gt;,&#125;\n\nSerde 会自动处理 Vec 类型\nuse serde_json;let family = Family &#123; members: vec![    People &#123; name: &quot;Tod&quot;.to_owned(), age: 3 &#125;,    People &#123; name: &quot;Curt&quot;.to_owned(), age: 2 &#125;,] &#125;;let json = serde_json::to_string(&amp;family).unwrap();println!(&quot;&#123;&#125;&quot;, json); // &#123;&quot;members&quot;:[&#123;&quot;name&quot;:&quot;Tod&quot;,&quot;age&quot;:3&#125;,&#123;&quot;name&quot;:&quot;Curt&quot;,&quot;age&quot;:2&#125;]&#125;let json = r#&quot;&#123;&quot;members&quot;:[&#123;&quot;name&quot;:&quot;Tod&quot;,&quot;age&quot;:3&#125;,&#123;&quot;name&quot;:&quot;Curt&quot;,&quot;age&quot;:2&#125;]&#125;&quot;#;let family: Family = serde_json::from_str(json).unwrap();println!(&quot;&#123;:?&#125;&quot;, family); // Family &#123; members: [People &#123; name: &quot;Tod&quot;, age: 3 &#125;, People &#123; name: &quot;Curt&quot;, age: 2 &#125;] &#125;\n\n结构体中的 HashMapSerde 支持序列化&#x2F;反序列化结构体中的 HashMap 类型, 例如:\nuse std::collections::HashMap;use serde::&#123;Serialize, Deserialize&#125;;#[derive(Serialize, Deserialize, Debug)]struct Family &#123;    members: HashMap&lt;String, People&gt;,&#125;\n\nSerde 会自动处理 HashMap 类型\nuse serde_json;let mut members = HashMap::new();members.insert(&quot;Tod&quot;.to_owned(), People &#123; name: &quot;Tod&quot;.to_owned(), age: 3 &#125;);members.insert(&quot;Curt&quot;.to_owned(), People &#123; name: &quot;Curt&quot;.to_owned(), age: 2 &#125;);let family = Family &#123; members &#125;;let json = serde_json::to_string(&amp;family).unwrap();println!(&quot;&#123;&#125;&quot;, json); // &#123;&quot;members&quot;:&#123;&quot;Curt&quot;:&#123;&quot;name&quot;:&quot;Curt&quot;,&quot;age&quot;:2&#125;,&quot;Tod&quot;:&#123;&quot;name&quot;:&quot;Tod&quot;,&quot;age&quot;:3&#125;&#125;&#125;let json = r#&quot;&#123;&quot;members&quot;:&#123;&quot;Curt&quot;:&#123;&quot;name&quot;:&quot;Curt&quot;,&quot;age&quot;:2&#125;,&quot;Tod&quot;:&#123;&quot;name&quot;:&quot;Tod&quot;,&quot;age&quot;:3&#125;&#125;&#125;&quot;#;let family: Family = serde_json::from_str(json).unwrap();println!(&quot;&#123;:?&#125;&quot;, family); // Family &#123; members: &#123;&quot;Tod&quot;: People &#123; name: &quot;Tod&quot;, age: 3 &#125;, &quot;Curt&quot;: People &#123; name: &quot;Curt&quot;, age: 2 &#125;&#125; &#125;\n","categories":["Coding"],"tags":["Rust","Serde","序列化","反序列化","Json","Yaml"]},{"title":"Nodejs 中的 Stream","url":"/2022/04/16/Coding/nodejs-stream-concept/","content":"Nodejs 中的 Stream详细介绍 Nodejs 中的 Stream(流) 的概念\nStreamStream 是一种抽象的数据结构, 是 Nodejs 中的一个抽象的接口, 许多对象都实现了这个接口, 如 http 服务器的 request 和 response 等\n为什么要使用 Stream在 Nodejs 中处理大文件时, 使用 fs.readFileSync 或 fs.writeFileSync 等方法会将文件整体写入内存, 而流的作用可以把这些数据拆分, 每次只写入一小部分数据, 如:\nvar fs = require(&quot;fs&quot;);var readStream = fs.createReadStream(&quot;a.mp4&quot;); // 创建可读流var writeStream = fs.createWriteStream(&quot;b.mp4&quot;); // 创建可写流readStream.on(&quot;data&quot;, function (chunk) &#123;  // 当有数据流出时，写入数据  writeStream.write(chunk);&#125;);readStream.on(&quot;end&quot;, function () &#123;  // 当没有数据时，关闭数据流  writeStream.end();&#125;);\n\n当然这样写还是有问题, 读取流的速度总是快于写入流, 每次读取都触发写入可能会导致写入不能跟上读取速度, 而造成写入滞塞, 应对这个问题, 读取流还包含一个 pipe 方法可以将读取事件临时暂停, 等待写入流程完成:\nfs.createReadStream(&#x27;a.mp4&#x27;).pipe(fs.createWriteStream(&#x27;b.mp4));// pipe自动调用了data,end等事件\n\nStream 来源 sourceStream 的常见来源方式有三种：\n\n从控制台输入\nhttp 请求中的 request\n读取文件\n\nStream 输出 destStream 的常见输出方式有三种：\n\n输出控制台\nhttp 请求中的 response\n写入文件\n\nStream 管道 pipe在 source 和 dest 之间有一个连接的管道 pipe,它的基本语法是 source.pipe(dest)，source 和 dest 就是通过 pipe 连接，让数据从 source 流向了 dest\nStream 应用场景Stream 的应用场景主要就是处理 IO 操作，而 http 请求和文件操作都属于 IO 操作。Stream 的本质——由于一次性 IO 操作过大，硬件开销太多，影响软件运行效率，因此将 IO 分批分段进行操作，让数据像水管一样流动起来，直到流动完成，也就是操作完成\n继承自 Stream 的类以下 4 个类继承自 Stream:\n\nReadable 可读流\nWritable 可写流\nDuplex 可读可写流\nTransform 在读写过程中可以修改和变换数据的 Duplex 流\n\n","categories":["Web"],"tags":["Nodejs","Stream","I/O","Http","Readdable","Writable"]},{"title":"2分钟搭建 github 文件下载加速服务","url":"/2024/06/13/Site/deploy-github-download-proxy/","content":"2 分钟搭建 github 文件下载加速服务今天发现一个加速 GitHub 下载的方法，体验非常不错！简单操作，仅花了 2 分钟就搞定了，速度也确实快了不少。\n创建 Cloudflare Worker使用 Cloudflare Worker 创建无服务器反代程序, 可以利用 Cloudflare 的国内 CDN 加速完成代理, 虽然免费版有一天 10 万次请求限制, 但自用也绰绰有余了\n首先进入 Workers 和 Pages 页面, 点击创建, 随后选择从模板开始中的 Hello World 模板\n\n进去后取个名字直接点击部署\n编辑代码点击编辑代码进入编辑器, 复制以下内容:\n&quot;use strict&quot;;/** * static files (404.html, sw.js, conf.js) */const ASSET_URL = &quot;https://hunshcn.github.io/gh-proxy/&quot;;// 前缀，如果自定义路由为example.com/gh/*，将PREFIX改为 &#x27;/gh/&#x27;，注意，少一个杠都会错！const PREFIX = &quot;/&quot;;// git使用cnpmjs镜像、分支文件使用jsDelivr镜像的开关，0为关闭，默认开启const Config = &#123;  jsdelivr: 1,  cnpmjs: 1,&#125;;/** @type &#123;RequestInit&#125; */const PREFLIGHT_INIT = &#123;  status: 204,  headers: new Headers(&#123;    &quot;access-control-allow-origin&quot;: &quot;*&quot;,    &quot;access-control-allow-methods&quot;:      &quot;GET,POST,PUT,PATCH,TRACE,DELETE,HEAD,OPTIONS&quot;,    &quot;access-control-max-age&quot;: &quot;1728000&quot;,  &#125;),&#125;;const exp1 =  /^(?:https?:\\/\\/)?github\\.com\\/.+?\\/.+?\\/(?:releases|archive)\\/.*$/i;const exp2 = /^(?:https?:\\/\\/)?github\\.com\\/.+?\\/.+?\\/(?:blob|raw)\\/.*$/i;const exp3 = /^(?:https?:\\/\\/)?github\\.com\\/.+?\\/.+?\\/(?:info|git-).*$/i;const exp4 =  /^(?:https?:\\/\\/)?raw\\.(?:githubusercontent|github)\\.com\\/.+?\\/.+?\\/.+?\\/.+$/i;const exp5 =  /^(?:https?:\\/\\/)?gist\\.(?:githubusercontent|github)\\.com\\/.+?\\/.+?\\/.+$/i;const exp6 = /^(?:https?:\\/\\/)?github\\.com\\/.+?\\/.+?\\/tags.*$/i;/** * @param &#123;any&#125; body * @param &#123;number&#125; status * @param &#123;Object&lt;string, string&gt;&#125; headers */function makeRes(body, status = 200, headers = &#123;&#125;) &#123;  headers[&quot;access-control-allow-origin&quot;] = &quot;*&quot;;  return new Response(body, &#123; status, headers &#125;);&#125;/** * @param &#123;string&#125; urlStr */function newUrl(urlStr) &#123;  try &#123;    return new URL(urlStr);  &#125; catch (err) &#123;    return null;  &#125;&#125;addEventListener(&quot;fetch&quot;, (e) =&gt; &#123;  const ret = fetchHandler(e).catch((err) =&gt;    makeRes(&quot;cfworker error:\\n&quot; + err.stack, 502)  );  e.respondWith(ret);&#125;);function checkUrl(u) &#123;  for (let i of [exp1, exp2, exp3, exp4, exp5, exp6]) &#123;    if (u.search(i) === 0) &#123;      return true;    &#125;  &#125;  return false;&#125;/** * @param &#123;FetchEvent&#125; e */async function fetchHandler(e) &#123;  const req = e.request;  const urlStr = req.url;  const urlObj = new URL(urlStr);  let path = urlObj.searchParams.get(&quot;q&quot;);  if (path) &#123;    return Response.redirect(&quot;https://&quot; + urlObj.host + PREFIX + path, 301);  &#125;  // cfworker 会把路径中的 `//` 合并成 `/`  path = urlObj.href    .substr(urlObj.origin.length + PREFIX.length)    .replace(/^https?:\\/+/, &quot;https://&quot;);  if (    path.search(exp1) === 0 ||    path.search(exp5) === 0 ||    path.search(exp6) === 0 ||    (!Config.cnpmjs &amp;&amp; (path.search(exp3) === 0 || path.search(exp4) === 0))  ) &#123;    return httpHandler(req, path);  &#125; else if (path.search(exp2) === 0) &#123;    if (Config.jsdelivr) &#123;      const newUrl = path        .replace(&quot;/blob/&quot;, &quot;@&quot;)        .replace(/^(?:https?:\\/\\/)?github\\.com/, &quot;https://cdn.jsdelivr.net/gh&quot;);      return Response.redirect(newUrl, 302);    &#125; else &#123;      path = path.replace(&quot;/blob/&quot;, &quot;/raw/&quot;);      return httpHandler(req, path);    &#125;  &#125; else if (path.search(exp3) === 0) &#123;    const newUrl = path.replace(      /^(?:https?:\\/\\/)?github\\.com/,      &quot;https://github.com.cnpmjs.org&quot;    );    return Response.redirect(newUrl, 302);  &#125; else if (path.search(exp4) === 0) &#123;    const newUrl = path      .replace(/(?&lt;=com\\/.+?\\/.+?)\\/(.+?\\/)/, &quot;@$1&quot;)      .replace(        /^(?:https?:\\/\\/)?raw\\.(?:githubusercontent|github)\\.com/,        &quot;https://cdn.jsdelivr.net/gh&quot;      );    return Response.redirect(newUrl, 302);  &#125; else &#123;    return fetch(ASSET_URL + path);  &#125;&#125;/** * @param &#123;Request&#125; req * @param &#123;string&#125; pathname */function httpHandler(req, pathname) &#123;  const reqHdrRaw = req.headers;  // preflight  if (    req.method === &quot;OPTIONS&quot; &amp;&amp;    reqHdrRaw.has(&quot;access-control-request-headers&quot;)  ) &#123;    return new Response(null, PREFLIGHT_INIT);  &#125;  const reqHdrNew = new Headers(reqHdrRaw);  let urlStr = pathname;  if (urlStr.startsWith(&quot;github&quot;)) &#123;    urlStr = &quot;https://&quot; + urlStr;  &#125;  const urlObj = newUrl(urlStr);  /** @type &#123;RequestInit&#125; */  const reqInit = &#123;    method: req.method,    headers: reqHdrNew,    redirect: &quot;manual&quot;,    body: req.body,  &#125;;  return proxy(urlObj, reqInit);&#125;/** * * @param &#123;URL&#125; urlObj * @param &#123;RequestInit&#125; reqInit */async function proxy(urlObj, reqInit) &#123;  const res = await fetch(urlObj.href, reqInit);  const resHdrOld = res.headers;  const resHdrNew = new Headers(resHdrOld);  const status = res.status;  if (resHdrNew.has(&quot;location&quot;)) &#123;    let _location = resHdrNew.get(&quot;location&quot;);    if (checkUrl(_location)) resHdrNew.set(&quot;location&quot;, PREFIX + _location);    else &#123;      reqInit.redirect = &quot;follow&quot;;      return proxy(newUrl(_location), reqInit);    &#125;  &#125;  resHdrNew.set(&quot;access-control-expose-headers&quot;, &quot;*&quot;);  resHdrNew.set(&quot;access-control-allow-origin&quot;, &quot;*&quot;);  resHdrNew.delete(&quot;content-security-policy&quot;);  resHdrNew.delete(&quot;content-security-policy-report-only&quot;);  resHdrNew.delete(&quot;clear-site-data&quot;);  return new Response(res.body, &#123;    status,    headers: resHdrNew,  &#125;);&#125;\n\n修改后点击保存并部署\n然后就能通过自动生成的 workers.dev 域名访问该页面了\n\n在输入框中输入 github 上的文件下载链接即可直接加速下载该文件了\n使用自定义域名要使用自定义域名访问该页面, 需要用 Cloudflare 托管你的域名\n在 Workers 和 Pages 页面中找到你部署的 Worker, 点击进入后进入设置页面, 在域和路由选项处点击添加, 然后输入你想要的域名并部署即可, 之后就可以通过该自定义域名访问代理页面了\n原项目https://github.com/hunshcn/gh-proxy\n","categories":["Site"],"tags":["Proxy","Github","Cloudflare","Worker"]},{"title":"使用github pages和hexo部署个人博客网站","url":"/2022/04/01/Site/hexo-github-pages/","content":"使用 github pages 和 hexo 部署个人博客网站在本篇博客中，我将详细介绍如何从零开始搭建个人博客网站，使用 Hexo 创建博客网站，并将其部署到 GitHub Pages，并最终绑定自定义域名。让我们一起来跟随下面的步骤进行：\n步骤一：使用 Hexo 创建博客网站\n安装 Node.js 和 Git：首先确保您的电脑上安装了 Node.js 和 Git。打开命令行工具，运行以下命令安装 Hexo：\n\nnpm install -g hexo-cli\n\n\n初始化项目：创建一个新的 Hexo 项目，并进入项目目录：\n\nhexo init my-blogcd my-blog\n\n\n添加新文章：创建新的文章，使用 Markdown 格式编写文章内容：\n\nhexo new &quot;My First Post&quot;\n\n步骤二：部署到 GitHub Pages\n创建 GitHub 仓库：在 GitHub 上创建一个新的仓库，用于存储博客网站的代码。\n\n编辑配置文件：打开 _config.yml 文件，修改 deploy 配置为 GitHub Pages：\n\n\ndeploy:type: gitrepo: https://github.com/your-username/your-repo.gitbranch: gh-pages\n\n\n安装 hexo-deployer-git：根目录下执行如下命令：\n\nnpm install hexo-deployer-git --save\n\n之后就可以让 hexo 使用 git 来部署页面到 github 仓库中\n\n部署网站：运行以下命令部署网站到 GitHub Pages：\n\nhexo deploy\n\n步骤三：绑定自定义域名\n配置 CNAME 文件：在博客项目目录中创建 CNAME 文件，输入您的自定义域名 domain.com。\n\n绑定域名：进入 GitHub 仓库设置，将您的自定义域名 domain.com 添加到仓库的 Custom Domain，点击 Save 后，github 会自动开始检查域名是否可用。\n\n配置 DNS 记录：在您的 DNS 控制面板中，添加一条 CNAME 记录，将域名指向 GitHub Pages 提供的域名 your-username.github.io.\n\n\n通过以上步骤，您将成功从零开始搭建个人博客网站，使用 Hexo 创建博客，并将其部署到 GitHub Pages，并绑定自定义域名。祝您的博客网站一切顺利！如有任何问题或需要帮助，请随时告诉我。希朿您顺利搭建个人博客网站！\n","categories":["Site"],"tags":["Hexo","GitHub Pages","博客","网站"]},{"title":"使用 next-on-pages 部署 nextjs 项目时遇到的一些问题","url":"/2024/01/23/Site/issues-about-next-on-pages/","content":"使用 next-on-pages 部署 nextjs 项目时遇到的一些问题使用 next-on-pages 将 nextjs 项目部署到 cloudflare 上时遇到的一些问题\n创建一个 next-on-pages 项目对于已有的 nextjs 项目, 可以在项目中添加 @cloudflare&#x2F;next-on-pages 依赖:\nnpm i -D @cloudflare/next-on-pages\n\n并且在构建时需要修改 scripts:\n&#123;  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;npx @cloudflare/next-on-pages@1&quot;,    // or    &quot;build&quot;: &quot;npx next-on-pages&quot;  &#125;&#125;\n\n部署到 cloudflare pages 上可以使用 wrangler 来进行部署\nnpm i -D wrangler\n\n部署命令:\n&#123;  &quot;scripts&quot;: &#123;    &quot;deploy&quot;: &quot;npm run build &amp;&amp; wrangler pages deploy&quot;  &#125;&#125;\n\n对于新建的项目, 则推荐直接使用 wrangler 来创建 nextjs 项目\nnpm create cloudflare@latest my-pages# 根据后续提示选择nextjs框架\n\n脚手架会创建一个基于 create-next-app 默认模板的 nextjs 项目, 随后开发流程和 nextjs 一样\nWindows 系统构建报错在 windows 上用 next-on-pages 构建 nextjs 项目时有时会出错, 通常抛出的是 nodejs 的 child_process 执行命令时的错误, 没有明确的错误说明\n但在使用 next-on-pages 也会提示在 windows 上不稳定:\n⚡️ Warning: It seems like you&#x27;re on a Windows system, the Vercel CLI (run by @cloudflare/next-on-pages⚡️ to build your application) seems not to work reliably on Windows so if you experience issues during⚡️ the build process please try switching to a different operating system or running⚡️ @cloudflare/next-on-pages under the Windows Subsystem for Linux\n\n所以可以将项目迁移到 linux 系统或 WSL 中来构建, 同时也需要将 npm 等基本环境安装到 WSL 中\n如果不想安装 WSL, 也可以将项目上传到 github 然后连接到 cloudflare pages 空间, 利用云服务器来进行构建\n如何在 cloudflare 上连接 github 仓库\n进入 cloudflare dashboard, 打开 Workers &amp; Pages 的 Overview 页面, 点击 Create\n\n\n\n选择 Pages 并点击 Connect to Git\n\n\ncloudflare 目前支持 github 和 gitlab 自动部署, 如果之前已经在 cloudflare 连接过 github 账号, 此时就已经能看到自己的 github 账号下的所有公开仓库了, 选择想要部署的项目然后点击 Begin Setup\n\n进入项目构建配置页面, 选择项目分支, 预设的开发框架, 输入构建命令和输出静态文件的目录(相对于根目录), 还可以选择添加环境变量或者改变根目录所在位置\n\n当选择 nextjs 作为开发框架时, cloudflare 通常会自动配置好命令和输出目录\n\n都配置好以后点击 Save and Deploy 就会开始自动构建和部署\n构建 nextjs 之前需要注意的细节需要注意的是, 在 cloudflare 上部署 nextjs 项目时, 项目中使用的 api 路由需要额外配置运行时为 edge\n项目中 &#x2F;api 下的所有 route.ts 中均需要加上如下代码:\nexport const runtime = &quot;edge&quot;;\n\n同时 nextjs 构建时也会强制执行 ts 类型检查, 需要注意项目中的 route.ts, layout.ts, page.ts 等文件中不要导出无关的代码\n","categories":["Site"],"tags":["next-on-pages","nextjs","cloudflare","wrangler"]},{"title":"一些关于hexo网站的小技巧","url":"/2022/04/01/Site/tricks-about-hexo/","content":"一些关于 hexo 网站的小技巧一些在使用 hexo 建站时有用的小技巧\n自动创建 post项目根目录执行以下命令:\nhexo new post my-blog\n\n执行后就会在 &#x2F;source&#x2F;_post 下新增一个 my-blog.md 文件, 并且会自动生成简单的 frontmatter 信息\n若想在_post 的子目录中创建文章, 则需要带上 -p 参数\nhexo new post -p blogs/my-blog\n\n这样则会在 &#x2F;source&#x2F;_post&#x2F;blogs 目录下创建文件\n显示菜单项打开根目录下的_config.yml, 或你使用的主题所在的目录下的_config.yml\n找到 menu: 配置项, 如下:\n# Usage: `Key: /link/ || icon`# Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-senstive.# Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.# When running the site in a subdirectory (e.g. yoursite.com/blog), remove the leading slash from link value (/archives -&gt; archives).# External url should start with http:// or https://menu:  home: / || fa fa-home  #about: /about/ || fa fa-user  #tags: /tags/ || fa fa-tags  #categories: /categories/ || fa fa-th  archives: /archives/ || fa fa-archive  #schedule: /schedule/ || fa fa-calendar  #sitemap: /sitemap.xml || fa fa-sitemap  #commonweal: /404/ || fa fa-heartbeat# Enable / Disable menu icons / item badges.menu_settings:  icons: true  badges: false\n\n取消对应菜单项的注释, 重新运行 hexo, 就可以看到相应菜单显示出来\n菜单项中每一个配置的规则为:\nUsage: `Key: /link/ || icon`\n\n若配置 tags 菜单, 该菜单会显示配置的 icon 的图标, 而点击该菜单时会去寻找 public&#x2F;tags 下的 index.html 页面\nhexo 默认会生成 home 和 archives 两个页面, 若需要显示其他页面, 则需要创建对应的 page, 如生成 tags 页面:\nhexo new page tags # 生成tags page\n\n此时在项目的 source&#x2F;tags 下会生成一个 index.md 文件, 打开该文件修改 frontmatter 如下:\n---title: tagsdate: 2020-01-01 00:00:00type: &quot;tags&quot;comments: false---\n\n再次运行 hexo, 点击 tags 菜单则会正确打开 tags 页面\n显示 github 图标在_config.yml 中找到 github_banner 配置项, 设置 enable 为 true, 并添加自己的 github 链接:\n# `Follow me on GitHub` banner in the top-right corner.github_banner:  enable: true  permalink: https://github.com/your-name  title: Follow me on GitHub\n\n隐藏内容点击展开使用 html5 提供的 details 标签, 在 summary 标签中写入隐藏时显示的文字, 在其后的 p 标签中写入详细内容, 如:\n&lt;details&gt;  &lt;summary&gt;标题&lt;/summary&gt;  &lt;p&gt;详情&lt;/p&gt;&lt;/details&gt;\n\n展示效果如下:\n\n  标题\n  详情\n\n\n自动添加 github pages 自定义域名由于 github 的限制, 在使用自定义域名时, 每次提交代码后自定义域名都会失效, 需要重新配置\n要解决这个问题, 只需要在 source 目录下添加一个 CNAME 文件, 并在其中写入你的域名即可, 如:\nyourdomain.net\n\n随后使用 hexo g 提交到 GitHub 上就会自动在 pages 中设置该自定义域名\n使用搜索功能安装相关插件:\nnpm i -S hexo-generator-searchdb\n\n在 _config.yml 配置文件中添加如下配置:\nsearch:  path: search.xml  field: post  format: html  limit: 10000\n\n使用 Next 主题时自带本地搜索设置, 编辑主题中的 _config.yml 文件中的 local_search:\n# Local_searchlocal_search:  eanble: true\n\n侧边栏社交链接侧边栏社交链接的配置有两部分, 一个是链接, 一个是连接图标, 在使用主题的 _config.yml 中配置\n链接在 social 配置项下面, 格式为 显示文本: 链接地址 || 显示的 Font Awesome 图标\nsocial:  GitHub: https://github.com/yourname || fab fa-github  #E-Mail: mailto:yourname@gmail.com || fa fa-envelope  #Weibo: https://weibo.com/yourname || fab fa-weibo  #Google: https://plus.google.com/yourname || fab fa-google  #Twitter: https://twitter.com/yourname || fab fa-twitter  #FB Page: https://www.facebook.com/yourname || fab fa-facebook  #StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow  #YouTube: https://youtube.com/yourname || fab fa-youtube  #Instagram: https://instagram.com/yourname || fab fa-instagram  #Skype: skype:yourname?call|chat || fab fa-skype\n\n图标的设置在 social_icons 配置项下面, 可以开启是否显示图标\nsocial_icons:  enable: true  icons_only: false  transition: false\n","categories":["Site"],"tags":["Hexo","博客","技巧"]},{"title":"Git 常用命令备忘","url":"/2022/10/13/Tools/git-commands/","content":"Git 常用命令备忘Git 常用命令备忘\nGit 配置用户信息git config --global user.name &quot;your name&quot;git config --global user.email &quot;your@email.com&quot;\n\n查看配置信息git config --listgit config -l\n\nGit 本地代理git config --global https.proxy http://127.0.0.1:1080git config --global https.proxy http://127.0.0.1:1080# unsetgit config --global --unset http.proxygit config --global --unset https.proxy\n\n常见状态\nuntracked: 未被 git 跟踪的文件\nunmodified: 未被修改的文件\nmodified: 已修改的文件\nstaged: 修改已被暂存的文件\n\n仓库管理Git 仓库初始化git init\n\n克隆远程仓库git clone https://github.com/your-name/your-repo# 克隆特定分支git clone -b dev https://github.com/your-name/your-repo\n\n检查文件状态git status\n\n暂存文件暂存的功能:\n\n把已跟踪的文件放入暂存区\n开始跟踪新文件\n合并时把有冲突的文件标记为已解决状态\n\ngit add &lt;file&gt;\n\n查看差异git diff # 对比工作目录中当前文件和暂存区中文件差异git diff --staged # 查看已暂存文件\n\n提交更新将暂存区快照进行提交\ngit commit # 直接输入会默认打开 vim 编辑器输入提交描述git commit -a # -a 参数会自动将已跟踪文件暂存并提交git commit -m &#x27;bugfix&#x27; # -m 参数为提交加上描述\n\n提交历史git log\n\n撤销操作修改最后一次 commitgit commit -m bugfixgit add &lt;file&gt;git --amend # 将 commit 之后 add 的文件加入到上次提交中\n\n使用 –amend 参数修改 commit 不会创建一个新的 commit\n取消暂存git reset &lt;file&gt;\n\n撤销修改git checkout &lt;file&gt; # 撤销到 staged 状态\n\n销毁暂存git clean -f # 删除未暂存文件git clean -fd # 删除未暂存文件和目录git clean -fxd # 删除未暂存文件和目录, 以及 gitignore 中标记的未跟踪文件/目录\n\ngit checkout -f # 丢弃暂存区中所有文件, 慎用!!!\n\n版本回退git reset --hard HEAD^git reset --hard [commit_id]\n\n版本回退保留更改git reset --soft HEAD^git reset --soft [commit_id]\n\n远程仓库查看远程仓库git remote # origin 是默认名称git remote -v # 显示 urlgit remote show [remote-name] # 显示远程仓库详细信息\n\n添加远程仓库git remote add [remote-name] &lt;url&gt; # 添加一个叫 remote-name 的远程仓库, 地址为 url\n\n拉取git fetch [remote-name] [branch]\n\n通过 fetch 拉取远程仓库会在本地拥有该仓库所有分支或指定分支的引用, 可以查看或合并, 但不会自动合并或修改当前工作\ngit pullgit branch --set-upstream-to=[remote-name]/[remote-branch] [local-branch] # 为还未设置远程分支的当前分支设置对应远程分支并拉取\n\n拉取远程分支到当前分支, 并进行自动合并\n推送git pushgit push -u [remote-name] [branch] # 为还未设置远程分支的当前分支设置对应远程分支并推送\n\n远程仓库的移除和重命名git remote rename [old-remote-name] [new-remote-name] # 重命名git remote remove [remote-name] # 移除\n\n标签轻量标签git tag &lt;tag name&gt; # 仅包含标签名信息\n\n附注标签git tag -a &lt;tag name&gt; # 包含打标签者名字, 邮箱, 日期等信息\n\n推送标签git push --tags # --tags 参数会将所有未推送的标签推送到远程仓库\n\n分支管理创建分支git branch [branch-name]git checkout -b [branch-name]\n\n查看分支git branch\n\n切换分支git checkout [branch-name]\n\n删除分支git branch -d [branch-name] # 删除本地分支git push [remote-name] -d [branch-name] # 删除远程仓库分支\n\n修改本地分支名称git branch -m [old-branch-name] [new-branch-name]\n\n合并分支git merge [branch-name]\n\n合并时变基, 整合提交记录, 避免过多分叉\ngit rebase [branch-name]\n\nGitignore使用 npm 开源包 ggig 可以方便的自动生成各种不同语言的 gitignore 文件\n安装 ggignpm install -g ggig\n\n查看支持的语言ggig ls# AL, Actionscript, Ada, Agda, Android, AppEngine, AppceleratorTitanium, ArchLinuxPackages, Autotools, Ballerina, C, C++, CFWheels, CMake, CUDA...\n\n创建指定语言的 gitignore 文件ggig gen --template Java# orggig gen -t Java\n","categories":["Tools"],"tags":["Git","命令行","常用命令"]},{"title":"Rust安装和更新","url":"/2022/05/21/Tools/rust-installation/","content":"Rust 安装和更新在 Windows 中安装和更新 rust, 并且配置墙内镜像源\n安装 rustuprustup 工具链需要 C++ 编译支持, 首先需要确保安装了 C++ 编译环境, 可优先下载安装Visual Studio\n确保安装了 C++ 编译环境后, 下载并安装Rustup\n配置 rustup 工具链镜像修改环境变量 RUSTUP_DIST_SERVER (默认值为 https://static.rust-lang.org) 和 RUSTUP_UPDATE_ROOT (默认值为 https://static.rust-lang.org/rustup)的值为墙内镜像源:\n# 清华大学RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup# 中国科学技术大学RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-staticRUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup# 上海交通大学RUSTUP_DIST_SERVER=https://mirrors.sjtug.sjtu.edu.cn/rust-static/\n\n配置 Cargo 镜像源打开 C:\\Users&lt;用户名&gt;.cargo\\config 文件, 如果没有则新建一个, 输入以下内容:\n[source.crates-io]registry = &quot;https://github.com/rust-lang/crates.io-index&quot;# 替换成要使用的镜像replace-with = &#x27;rsproxy&#x27;# 中国科学技术大学[source.ustc]registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;# 如果所处的环境中不允许使用 git 协议，可以把上述地址改为 https 协议#registry = &quot;https://mirrors.ustc.edu.cn/crates.io-index&quot;# 清华大学[source.tuna]registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;# 上海交通大学[source.sjtu]registry = &quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;# rustcc 社区[source.rustcc]registry = &quot;git://crates.rustcc.cn/crates.io-index&quot;# rsproxy[source.rsproxy]registry = &quot;https://rsproxy.cn/crates.io-index&quot;[source.rsproxy-sparse]registry = &quot;sparse+https://rsproxy.cn/index/&quot;[registries.rsproxy]index = &quot;https://rsproxy.cn/crates.io-index&quot;[net]git-fetch-with-cli=true\n\n如果更换 cargo 源后执行 cargo build 命令出现如下错误:\nblocking waiting for file lock on package cache lock\n\n可以删除 C:\\Users&lt;用户名&gt;.cargo.package-cache 文件\nrust 升级检查是否有更新和升级 rustup\nrustup checkrustup update\n","categories":["Coding"],"tags":["Rust","Rustup","Cargo","镜像源"]},{"title":"Antd Table 拖动控制列宽度","url":"/2023/02/13/Web/antd-table-dynamic-column-width/","content":"Antd Table 拖动控制列宽度介绍如何实现 antd table 组件头部可通过拖拽来改变列的宽度\n背景最近一个项目有一个需求, 使用表格组件时需要让表格头部列的边框可以横向拖拽, 并且拖拽后需要改变该列的宽度, antd 的 table 组件中并没有实现这个功能, 所以需要自己二次封装\n需求\n表格列头部右部边框可横向拖拽\n拖拽中显示一条贯穿表格的纵向虚线展示当前拖到的位置\n拖拽完成后更新该列的宽度到鼠标松开后的位置\n\n封装 table 组件由于 antd table 并没有提供类似功能, 所以需要将 table 组件二次封装, 以下是封装后的 Table 组件代码\n// Table.tsximport &#123; Table as AntdTable, TableProps &#125; from &quot;antd&quot;;import &#123; useState &#125; from &quot;react&quot;;import &#123; DraggableHeaderBorder &#125; from &quot;./ResizableHeader&quot;;/** * antd table 的 components api 中, row 字段的函数参数类型没有导出 * 所以需要自己定义一个, 其中包含 column 中的相关信息 */interface ITableRowProps &#123;  children: &#123;    key: string;    props: &#123;      children: string;      column: &#123;        dataIndex: string;        title: string;        key: string;        width?: number;      &#125;;    &#125;;  &#125;[];&#125;export const Table = &lt;T,&gt;(&#123; columns, ...props &#125;: TableProps&lt;T&gt;) =&gt; &#123;  // 创建一个基于传入的 columns 的新的值  const [mergedColumns, setCol] = useState(columns);  return (    &lt;AntdTable&lt;T&gt;      &#123;...props&#125;      columns=&#123;mergedColumns&#125;      // components api 用于替换 table 中的原有组件      components=&#123;&#123;        header: &#123;          row: (props: ITableRowProps) =&gt; &#123;            return (              &lt;tr&gt;                // 便遍历所有 column, 并重新生成自定义的 th                &#123;props.children.map((item) =&gt; &#123;                  return (                    &lt;DraggableHeaderBorder                      key=&#123;item.key&#125;                      title=&#123;item.props.children&#125;                      onChange=&#123;(width) =&gt; &#123;                        const key = item.key;                        setCol(                          mergedColumns?.map((col) =&gt;                            col.key === key ? &#123; ...col, width &#125; : col                          )                        );                      &#125;&#125;                      width=&#123;item.props.column.width&#125;                    /&gt;                  );                &#125;)&#125;              &lt;/tr&gt;            );          &#125;,        &#125;,      &#125;&#125;    /&gt;  );&#125;;\n\n其中, DraggableHeaderBorder 是可拖拽组件, 该组件的实现如下:\nimport &#123; FC, memo, useEffect, useRef &#125; from &quot;react&quot;;interface IProps &#123;  title: string;  // 用于获取表格组件的高度和top偏移量以定位拖拽时的边框组件位置  onChange: (width: number) =&gt; void;  // 如果没有宽度则不支持拖拽  width?: number;&#125;// 可拖拽组件通用类const defaultClasses = &quot;w-1 border-r&quot;;// 拖拽前的类const beforeDraggingClasses =  &quot;absolute top-1/2 -translate-y-1/2 right-0 h-4 border-secondary-neutral&quot;;// 拖拽中的类const draggingClasses =  &quot;border-dashed fixed border-quaternary-content z-[9999]&quot;;export const DraggableHeaderBorder: FC&lt;IProps&gt; = memo(  (&#123; title, width, onChange &#125;) =&gt; &#123;    const thRef = useRef&lt;HTMLTableCellElement&gt;(null); // 用于获取默认分配的列表头宽度    const borderRef = useRef&lt;HTMLSpanElement&gt;(null); // 可拖拽组件    const initLeft = useRef&lt;number&gt;(0); // 初始位置    const endLeft = useRef&lt;number&gt;(0); // 结束位置    /**     * 开始拖拽的回调函数     * @param &#123;MouseEvent&#125; e     */    function handleDragStart(e: MouseEvent) &#123;      e.preventDefault();      e.stopPropagation();      // 记录拖拽开始时的位置      initLeft.current = Math.floor(e.clientX);      // 找到表格容器父组件, 并获取其高度, 用于确定拖拽时的纵向虚线的高度      const height =        (e.target! as HTMLElement).closest(&quot;.ant-table-container&quot;)          ?.clientHeight ?? 0;      const top = e.clientY;      borderRef.current!.setAttribute(        &quot;class&quot;,        defaultClasses + &quot; &quot; + draggingClasses      );      borderRef.current!.setAttribute(        &quot;style&quot;,        `left:$&#123;initLeft.current&#125;px;top:$&#123;top&#125;px;height:$&#123;height&#125;px`      );      window.addEventListener(&quot;mousemove&quot;, handleDragOver);      window.addEventListener(&quot;mouseup&quot;, handleDragEnd);    &#125;    /**     * 拖拽中的回调函数     * @param &#123;MouseEvent&#125; e     */    function handleDragOver(e: MouseEvent) &#123;      e.preventDefault();      e.stopPropagation();      const x = Math.floor(e.clientX);      borderRef.current!.style.left = `$&#123;x&#125;px`;    &#125;    /**     * 结束拖拽的回调函数     * @param &#123;MouseEvent&#125; e     */    function handleDragEnd(e: MouseEvent) &#123;      e.preventDefault();      e.stopPropagation();      if (borderRef.current) &#123;        // 记录拖拽结束时的位置        endLeft.current = borderRef.current.offsetLeft;        // 恢复之前的样式        borderRef.current.setAttribute(          &quot;class&quot;,          defaultClasses + &quot; cursor-col-resize &quot; + beforeDraggingClasses        );        borderRef.current.setAttribute(&quot;style&quot;, &quot;&quot;);        // 定位到新位置并提交变更后宽度        const diff = endLeft.current - initLeft.current;        const width = thRef.current!.offsetWidth + diff;        onChange(width);      &#125;      // 鼠标按键抬起时清除鼠标移动的事件监听      window.removeEventListener(&quot;mousemove&quot;, handleDragOver);    &#125;    useEffect(() =&gt; &#123;      if (borderRef.current &amp;&amp; width) &#123;        // 设置了宽度的col才能拖拽修改宽度        borderRef.current.addEventListener(&quot;mousedown&quot;, handleDragStart);      &#125;      // 组件销毁时清除事件监听      return () =&gt; &#123;        if (borderRef.current &amp;&amp; width) &#123;          borderRef.current.removeEventListener(&quot;mousedown&quot;, handleDragStart);          window.removeEventListener(&quot;mouseup&quot;, handleDragEnd);        &#125;      &#125;;    &#125;, []);    return (      &lt;th        className=&quot;relative h-[32px] !p-3 before:!content-none&quot;        ref=&#123;thRef&#125;        style=&#123;width ? &#123; width &#125; : &#123;&#125;&#125;      &gt;        &lt;span className=&quot;inline-block w-full&quot;&gt;&#123;title&#125;&lt;/span&gt;        &lt;span          ref=&#123;borderRef&#125;          className=&#123;            defaultClasses +            &quot; &quot; +            beforeDraggingClasses +            `$&#123;width ? &quot; cursor-col-resize&quot; : &quot;&quot;&#125;`          &#125;        &gt;&lt;/span&gt;      &lt;/th&gt;    );  &#125;);\n\n该组件生成一个带可拖拽元素的 th 元素, 将其导入到 antd table 的 components api 中的 header.row 字段作为替换的元素即可\n随后引入封装后的组件, 使用和 antd table 一样的 api, 即可渲染出能通过拖拽改变列宽度的表格\n\n","categories":["Web"],"tags":["Antd","React","Table","Thead","拖动","列宽度"]},{"title":"国内镜像源(NPM, Cargo, Rustup, Git)","url":"/2022/05/01/Tools/inland-registry-mirrors/","content":"国内镜像源(NPM, Cargo, Rustup)记录各种包管理工具的国内镜像源 url 与设置方式\nNPMhttps://registry.npmmirror.com\n\nnpm config set registry https://registry.npmmirror.com\n\nnpm i -g pnpm --registry=https://registry.npmmirror.com\n\nnpm 设置代理\nnpm config set proxy http://127.0.0.1:1080npm config set https-proxy http://127.0.0.1:1080\n\nnpm 删除代理设置\nnpm config delete proxynpm config delete https-proxy\n\nPIP# 阿里云pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/# 豆瓣pip config set global.index-url https://pypi.douban.com/simple/# 清华大学pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple/# 中国科学技术大学pip config set global.index-url https://pypi.mirrors.ustc.edu.cn/simple/\n\npip 设置代理\npip config set global.proxy http://127.0.0.1:8080# orpip config set global.http_proxy http://127.0.0.1:8080pip config set global.https_proxy http://127.0.0.1:8080\n\nRustup修改环境变量 RUSTUP_DIST_SERVER (默认值为 https://static.rust-lang.org) 和 RUSTUP_UPDATE_ROOT (默认值为 https://static.rust-lang.org/rustup)的值为墙内镜像源:\n# 清华大学RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup# 中国科学技术大学RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-staticRUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup# 上海交通大学RUSTUP_DIST_SERVER=https://mirrors.sjtug.sjtu.edu.cn/rust-static/\n\nCargo打开 C:\\Users&lt;用户名&gt;.cargo\\config 文件, 如果没有则新建一个, 输入以下内容:\n[source.crates-io]registry = &quot;https://github.com/rust-lang/crates.io-index&quot;# 替换成要使用的镜像replace-with = &#x27;rsproxy&#x27;# 中国科学技术大学[source.ustc]registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;# 如果所处的环境中不允许使用 git 协议，可以把上述地址改为 https 协议#registry = &quot;https://mirrors.ustc.edu.cn/crates.io-index&quot;# 清华大学[source.tuna]registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;# 上海交通大学[source.sjtu]registry = &quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;# rustcc 社区[source.rustcc]registry = &quot;git://crates.rustcc.cn/crates.io-index&quot;# rsproxy[source.rsproxy]registry = &quot;https://rsproxy.cn/crates.io-index&quot;[source.rsproxy-sparse]registry = &quot;sparse+https://rsproxy.cn/index/&quot;[registries.rsproxy]index = &quot;https://rsproxy.cn/crates.io-index&quot;[net]git-fetch-with-cli=true\n\n如果更换 cargo 源后执行 cargo build 命令出现如下错误:\nblocking waiting for file lock on package cache lock\n\n可以删除 C:\\Users&lt;用户名&gt;.cargo.package-cache 文件\nGit 本地代理git config --global https.proxy http://127.0.0.1:1080git config --global https.proxy http://127.0.0.1:1080# unsetgit config --global --unset http.proxygit config --global --unset https.proxy\n","categories":["Tools"],"tags":["Git","Rustup","Cargo","镜像","NPM"]},{"title":"Windows cmd 常用命令备忘","url":"/2022/04/13/Tools/win-cmd-commands/","content":"Windows cmd 常用命令备忘cd 命令D: # 进入D盘cd /? # 使用帮助cd \\  # 进入当前盘根目录cd C:\\WINDOWS  # 进入当前盘其他目录cd /d E:\\dir  # 进入其他盘某个目录, 必须加 /d 参数cd ..  # 跳转上一层目录\n\n查看目录文件dir  # 查看当前目录下的文件dir /a  # 查看当前目录下的包含隐藏文件的所有文件\n\n创建和删除目录md test_dir  # 创建空目录mkdir test_dir  # 创建空目录rd /q/s test_dir  # 删除目录, /q 表示安静模式, /s 将会删除目录树rmdir /q/s test_dir  # 删除目录, /q 表示安静模式, /s 将会删除目录树\n\n文件处理copy path\\to\\file path\\to\\file # 复制一个文件到另一个位置move path\\to\\file path\\to\\file # 移动一个文件到另一个位置del path\\to\\file # 删除一个文件\n\n结束进程TASKKILL/P [password] 为提供的用户上下文指定密码。如果忽略，提示输入。/F 指定要强行终止的进程。/FI filter 指定筛选进或筛选出查询的的任务。/PID process id 指定要终止的进程的PID。/IM image name 指定要终止的进程的映像名称。通配符 &#x27;*&#x27;可用来指定所有映像名。/T Tree kill: 终止指定的进程和任何由此启动的子进程。/? 显示帮助/用法。\n\n查看网络连接状态netstat-a或--all：显示所有连线中的Socket；-A&lt;网络类型&gt;或--&lt;网络类型&gt;：列出该网络类型连线中的相关地址；-c或--continuous：持续列出网络状态；-C或--cache：显示路由器配置的快取信息；-e或--extend：显示网络其他相关信息；-F或--fib：显示FIB；-g或--groups：显示多重广播功能群组组员名单；-h或--help：在线帮助；-i或--interfaces：显示网络界面信息表单；-l或--listening：显示监控中的服务器的Socket；-M或--masquerade：显示伪装的网络连线；-n或--numeric：直接使用ip地址，而不通过域名服务器；-N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称；-o或--timers：显示计时器；-p或--programs：显示正在使用Socket的程序识别码和程序名称；-r或--route：显示Routing Table；-s或--statistice：显示网络工作信息统计表；-t或--tcp：显示TCP传输协议的连线状况；-u或--udp：显示UDP传输协议的连线状况；-v或--verbose：显示指令执行过程；-V或--version：显示版本信息；-w或--raw：显示RAW传输协议的连线状况；-x或--unix：此参数的效果和指定&quot;-A unix&quot;参数相同；--ip或--inet：此参数的效果和指定&quot;-A inet&quot;参数相同。\n\nfindfind/V         显示所有未包含指定字符串的行。/C         仅显示包含字符串的行数。/N         显示行号。/I         搜索字符串时忽略大小写。/OFF[LINE] 不要跳过具有脱机属性集的文件。&quot;string&quot; 指定要搜索的文本字符串。[drive:][path]filename 指定要搜索的文件。如果没有指定路径，FIND 将搜索在提示符处键入的文本或者由另一命令产生的文本。netstat --ano | find &quot;:8&quot; # 使用管道符模糊查询\n","categories":["Tools"],"tags":["命令行","常用命令","Windows","cmd"]},{"title":"用于打印的CSS","url":"/2022/04/16/Web/css-for-printing/","content":"用于打印的 CSS介绍如何使用 CSS 来控制打印的外观\n@pageCSS 中有一个名为 @page 的规则，它通知浏览器有关您网站打印偏好的信息。通常，我使用\n@page &#123;  size: Letter portrait;  margin: 0;&#125;\n\n在稍后关于边距的部分，我将解释为什么我选择了 margin: 0。您应根据与公制的关系选择使用 Letter 或 A4。\n设置 @page 的大小和边距并不同于设置 html 或 body 元素的宽度、高度和边距。@page 位于 DOM 之外 — 它包含了 DOM。在 Web 上，html 元素受屏幕边缘限制，但在打印时受 @page 限制。\n@page 控制的设置更多或更少对应于在按 Ctrl+P 时浏览器的打印对话框中得到的设置。\n这是我用来进行一些实验的示例文件。\n&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;style&gt;    @page &#123;      /* see below for each experiment */    &#125;    html &#123;      width: 100%;      height: 100%;      background-color: lightblue;      /* grid by shunryu111 https://stackoverflow.com/a/32861765/5430534 */      background-size: 0.25in 0.25in;      background-image: linear-gradient(to right, gray 1px, transparent 1px),        linear-gradient(to bottom, gray 1px, transparent 1px);    &#125;  &lt;/style&gt;  &lt;body&gt;    &lt;h1&gt;Sample text&lt;/h1&gt;    &lt;p&gt;sample text&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;\n\n在浏览器中看起来是这样的:\n\n然后这里是写入不同 @page 值的外观:\n@page &#123;  size: Letter portrait;  margin: 1in;&#125;\n\n\n@page &#123;  size: Letter landscape;  margin: 1in;&#125;\n\n\n@page &#123;  size: Letter landscape;  margin: 0;&#125;\n\n\n设置 @page 的尺寸实际上不会将该尺寸的纸张放入打印机的进纸盘中。您需要自己完成这部分。\n注意当我将尺寸设置为 A5 时，我的打印机仍保持在 Letter 尺寸，而 A5 尺寸完全适合在 Letter 尺寸内，这给人以边距的外观，尽管这并非来自于边距设置。\n@page &#123;  size: A5 portrait;  margin: 0;&#125;\n\n\n但如果我告诉打印机我已加载了真实的 A5 纸张，那么打印效果就会如预期。\n\n根据我的实验，我得出的结论是，Chrome 只有在将边距设置为默认时才遵循 @page 规则。一旦您在打印对话框中更改边距，您的输出效果就会成为您的物理纸张尺寸与所选边距的结合产品。\n即使您选择一个完全适合您的物理纸张的 @page 尺寸，边距仍然很重要。在这里，我创建了一个没有边距的 5x5 正方形，以及一个带边距的 5x5 正方形。html 元素的尺寸由 @page 尺寸和边距的组合所限制。\n@page &#123;  size: 5in 5in;  margin: 0;&#125;\n\n\n我进行所有这些测试并不是因为我期望在 A5 或 5x5 纸张上打印，而是因为我花了一些时间来弄清楚 @page 到底是什么。现在我非常有信心始终使用 Letter 并将边距设为 0\n@media print有一个名为 print 的媒体查询，您可以在其中编写仅在打印时应用的样式。我的生成器页面通常包含页眉、一些选项和一些帮助用户的文本，显然这些内容不应在打印时显示，因此在这里将这些元素添加 display:none\n/* Normal styles that appear while you are preparing the document */header &#123;  display: block;&#125;@media print &#123;  /* Disappear when you are printing the document */  header &#123;    display: none;  &#125;&#125;\n\n\nWidth, height, margin, padding您需要了解一些关于盒模型的知识，以便在不费太多功夫的情况下获得您想要的边距。\n\n我总是将 @page 的 margin 设置为 0 的原因是，我宁愿在 DOM 元素上处理边距。当我尝试使用 @page 设置 margin 为 0.5in 时，我经常会意外地得到双倍边距，导致内容比我预期的要挤压，我的单页设计溢出到第二页。\n如果我想使用 @page 的 margin，那么实际的页面内容需要紧贴在 DOM 的边缘上，这对我来说更难思考，也更难在打印前进行预览。对我来说，在头脑中记住 html 占据整张物理纸张，而边距在 DOM 内而不是在 DOM 之外，会更容易一些。\n@page &#123;  size: Letter portrait;  margin: 0;&#125;html,body &#123;  width: 8.5in;  height: 11in;&#125;\n\n在多页面打印生成器中，您需要一个表示每个页面的单独 DOM 元素。由于您不能有多个 html 或 body，您需要另一个元素。我喜欢使用 article。即使对于单页面生成器，您也可以始终使用 article。\n由于每个 article 代表一页，我不希望在 html 或 body 上有任何边距或填充。我们将逻辑推进一步 — 对我来说，让 article 占据整张物理页面并将边距放在其中会更容易一些。\n@page &#123;  size: Letter portrait;  margin: 0;&#125;html,body &#123;  margin: 0;&#125;article &#123;  width: 8.5in;  height: 11in;&#125;\n\n当我谈到在我的 article 中添加边距时，我不是使用 margin 属性，而是使用 padding。这是因为 margin 在盒模型中是在元素外部和周围的。如果您使用 0.5in 的边距，您将不得不将 article 设置为 7.5×10，以便 article 加上 2× 边距等于 8.5×11。如果您想要调整边距，您将不得不调整其他尺寸。\n相反，padding 放在元素内部，因此我可以将 article 定义为 8.5×11，带有 0.5in 的内边距，article 内的所有元素将保持在页面上。\n当您设置 box-sizing: border-box 时，关于元素尺寸的许多直觉更容易理解。这样可以锁定 article 的外部尺寸，同时调整内部 padding。这是我的代码片段：\nhtml &#123;  box-sizing: border-box;&#125;*,*:before,*:after &#123;  box-sizing: inherit;&#125;\n\n将这些代码合并起来:\n@page &#123;  size: Letter portrait;  margin: 0;&#125;html &#123;  box-sizing: border-box;&#125;*,*:before,*:after &#123;  box-sizing: inherit;&#125;html,body &#123;  margin: 0;&#125;article &#123;  width: 8.5in;  height: 11in;  padding: 0.5in;&#125;\n\n\n元素定位一旦您设置好了 article 和边距，article 内部的空间就完全由您自行决定如何使用。设计您的文档时，可以根据项目选择使用任何您认为合适的 HTML&#x2F;CSS。有时这意味着使用 flex 或 grid 布局元素，因为您在输出方面有一些灵活性。有时这意味着创建特定尺寸的方块以适合某个品牌的贴纸纸张。有时这意味着绝对定位所有内容到毫米，因为用户需要将特殊的预标记纸张放入打印机，在其上打印您的数据，而您无法控制那种特殊纸张。\n我在这里不是为了教授如何撰写一般的 HTML 教程，所以您需要能够做到这一点。我只能说的是，请注意您正在处理的是一张纸的有限空间，而不是像浏览器窗口那样可以滚动和缩放到任意长度或比例。如果您的文档将包含任意数量的项目，请准备通过创建更多的 article 来进行分页。\n多页文档和重复元素&lt;table&gt;  &lt;thead&gt;    &lt;tr&gt;      &lt;th&gt;Sample text&lt;/th&gt;      &lt;th&gt;Sample text&lt;/th&gt;    &lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;    &lt;tr&gt;      &lt;td&gt;0&lt;/td&gt;      &lt;td&gt;0&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;1&lt;/td&gt;      &lt;td&gt;1&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;2&lt;/td&gt;      &lt;td&gt;4&lt;/td&gt;    &lt;/tr&gt;    ...  &lt;/tbody&gt;&lt;/table&gt;\n\n如果只是打印一个普通的没有复杂样式的 table 很简单，但在许多实际情况下并不是那么简单。我重新创建的文档通常每页顶部都有抬头，底部有页脚，以及其他需要在每页明确重复的自定义元素。如果只是在多页之间打印一个很长的表格，您在中间页上就没有太多机会将其他元素放在它的上方、下方或周围。\n因此，我使用 JavaScript 生成页面，将表格分割为多个较小的部分。总体的方法如下：\n\n将 article 元素视为可丢弃的，随时准备从内存中的对象重新生成它们。所有用户输入和配置应该在单独的页眉&#x2F;选项框中进行，而不是在 article 中。\n编写一个名为 new_page 的函数，用于创建具有必要重复的页眉&#x2F;页脚等的新 article 元素。\n编写一个名为 renderpages 的函数，从基本数据创建 article，每次填满上一个 article 时调用 newpage。我通常使用 offsetTop 查看内容何时到达页面的较远处，尽管您肯定可以使用更智能的技术来实现每页的完美适配。\n每当基本数据更改时调用 render_pages。\n\nfunction delete_articles() &#123;  for (const article of Array.from(document.getElementsByTagName(&quot;article&quot;))) &#123;    document.body.removeChild(article);  &#125;&#125;function new_page() &#123;  const article = document.createElement(&quot;article&quot;);  article.innerHTML = `    &lt;header&gt;...&lt;/header&gt;    &lt;table&gt;...&lt;/table&gt;    &lt;footer&gt;...&lt;/footer&gt;    `;  document.body.append(article);  return article;&#125;function render_pages() &#123;  delete_articles();  let page = new_page();  let tbody = page.query(&quot;table tbody&quot;);  for (const line_item of line_items) &#123;    // I usually pick this threshold by experimentation but you can probably    // do something more rigorously correct.    if (tbody.offsetTop + tbody.offsetParent.offsetTop &gt; 900) &#123;      page = new_page();      tbody = page.query(&quot;table tbody&quot;);    &#125;    const tr = document.createElement(&quot;tr&quot;);    tbody.append(tr);    // ...  &#125;&#125;\n\n通常在页面上包含一个”第 X 页，共 Y 页”的计数器是很有意义的。由于直到所有页面生成后才知道页数，所以我无法在循环中完成这个操作。我在最后调用类似下面的函数：\nfunction renumber_pages() &#123;  let pagenumber = 1;  const pages = document.getElementsByTagName(&quot;article&quot;);  for (const page of pages) &#123;    page.querySelector(&quot;.pagenumber&quot;).innerText = pagenumber;    page.querySelector(&quot;.totalpages&quot;).innerText = pages.length;    pagenumber += 1;  &#125;&#125;\n\nPortrait &#x2F; Landscape 模式我已经展示了 @page 规则有助于告知浏览器的默认打印设置，但用户可以在需要时进行覆盖。如果您将 @page 设置为纵向模式，而用户将其覆盖为横向模式，您的布局和分页可能看起来不正确，特别是如果您正在硬编码任何页面阈值。\n您可以通过为纵向和横向分别创建 style 元素，并使用 JavaScript 在它们之间进行切换来满足用户需求。可能有更好的方法来实现这一点，但类似 @page 这样的 at-rules 的行为与常规 CSS 属性不同，所以我不太确定。您还应该保存一些变量，以帮助 render_pages 函数正确执行操作。\n您也可以停止硬编码阈值，但那样我就要听从我自己的建议。\n&lt;select onchange=&quot;return page_orientation_onchange(event);&quot;&gt;  &lt;option selected&gt;Portrait&lt;/option&gt;  &lt;option&gt;Landscape&lt;/option&gt;&lt;/select&gt;\n\n&lt;style id=&quot;style_portrait&quot; media=&quot;all&quot;&gt;  @page &#123;    size: Letter portrait;    margin: 0;  &#125;  article &#123;    width: 8.5in;    height: 11in;  &#125;&lt;/style&gt;&lt;style id=&quot;style_landscape&quot; media=&quot;not all&quot;&gt;  @page &#123;    size: Letter landscape;    margin: 0;  &#125;  article &#123;    width: 11in;    height: 8.5in;  &#125;&lt;/style&gt;\n\nlet print_orientation = &quot;portrait&quot;;function page_orientation_onchange(event) &#123;  print_orientation = event.target.value.toLocaleLowerCase();  if (print_orientation == &quot;portrait&quot;) &#123;    document.getElementById(&quot;style_portrait&quot;).setAttribute(&quot;media&quot;, &quot;all&quot;);    document.getElementById(&quot;style_landscape&quot;).setAttribute(&quot;media&quot;, &quot;not all&quot;);  &#125;  if (print_orientation == &quot;landscape&quot;) &#123;    document.getElementById(&quot;style_landscape&quot;).setAttribute(&quot;media&quot;, &quot;all&quot;);    document.getElementById(&quot;style_portrait&quot;).setAttribute(&quot;media&quot;, &quot;not all&quot;);  &#125;  render_printpages();&#125;function render_printpages() &#123;  if (print_orientation == &quot;portrait&quot;) &#123;    // ...  &#125; else &#123;    // ...  &#125;&#125;\n\n数据源有几种方法可以将数据放在页面上。有时，我将所有数据打包到 URL 参数中，因此 JavaScript 只需执行 const urlparams &#x3D; new URLSearchParams(window.location.search); 然后一堆 urlparams.get(“title”)。这样做有一些优势：\n\n页面加载非常快。\n通过更改 URL 来调试和实验非常容易。\n生成器可以脱机工作。\n\n这也有一些缺点：\n\nURL 变得非常长而混乱，人们不能舒适地通过电子邮件相互发送它们。请参见本文章顶部的示例链接。\n如果 URL 确实通过电子邮件发送，即使以后数据库中的源记录发生变化，这些数据也会“被锁定”。\n浏览器对 URL 长度有限制。这些限制非常高，但并非无限，而且可能因客户端而异。\n\n有时候，我相反使用 JavaScript 通过 API 获取我们的数据库记录，因此 URL 参数只包含记录的主键和可能的模式设置。\n这有一些优点：\n\nURL 长度更短。\n数据始终是最新的。\n\n以及一些缺点：\n\n用户必须等待一会儿，直到数据被获取。\n您需要编写更多的代码。\n\n有时我会在 article 上设置 contenteditable，以便用户在打印前进行小的更改。我也喜欢使用用户可以在打印前点击的实际复选框输入框。这些功能增加了一些便利性，但在大多数情况下，更明智的做法是让用户首先更改数据库中的源记录。此外，它们限制了您将 article 元素视为可丢弃的能力。\n完整代码&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;style&gt;    @page &#123;      size: Letter portrait;      margin: 0;    &#125;    html &#123;      box-sizing: border-box;    &#125;    *,    *:before,    *:after &#123;      box-sizing: inherit;    &#125;    html,    body &#123;      margin: 0;      background-color: lightblue;    &#125;    header &#123;      background-color: white;      max-width: 8.5in;      margin: 8px auto;      padding: 8px;    &#125;    article &#123;      background-color: white;      padding: 0.5in;      width: 8.5in;      height: 11in;      /* For centering the page on the screen during preparation */      margin: 8px auto;    &#125;    @media print &#123;      html,      body &#123;        background-color: white !important;      &#125;      body &gt; header &#123;        display: none;      &#125;      article &#123;        margin: 0 !important;      &#125;    &#125;  &lt;/style&gt;  &lt;body&gt;    &lt;header&gt;      &lt;p&gt;Some help text to explain the purpose of this generator.&lt;/p&gt;      &lt;p&gt;&lt;button onclick=&quot;return window.print();&quot;&gt;Print&lt;/button&gt;&lt;/p&gt;    &lt;/header&gt;    &lt;article&gt;      &lt;h1&gt;Sample page 1&lt;/h1&gt;      &lt;p&gt;sample text&lt;/p&gt;    &lt;/article&gt;    &lt;article&gt;      &lt;h1&gt;Sample page 2&lt;/h1&gt;      &lt;p&gt;sample text&lt;/p&gt;    &lt;/article&gt;  &lt;/body&gt;&lt;/html&gt;\n","categories":["Web"],"tags":["HTML","CSS","打印","媒体查询"]},{"title":"React 细节整理","url":"/2022/05/01/Web/react-details/","content":"React 细节整理实际使用中遇到的一些 React 操作的细节和问题的记录\n为什么开发环境中在挂在组件时使用 useEffect 会触发两次副作用A: React 18 开始, 在 development 模式, 且使用了 strict mode 情况下, 挂载组件的 useEffect 会执行两次, 为了方便开发者模拟挂载后立即卸载组件, 可以提前发现重复挂载是否出现 bug\n组件的 key 有什么作用A: key 涉及到组件树的 diff 算法, diff 有如下规则:\n\n当元素类型变化时，会销毁重建\n当元素类型不变时，对比属性\n当组件元素类型不变时，通过 props 递归判断子节点\n递归对比子节点，当子节点是列表时，通过 key 和 props 来判断。若 key 一致，则进行更新，若 key 不一致，就销毁重建\n\nkey 的取值分为三种: 不定值, 索引值, 唯一值\n\n不定值: 如 Math.random(), 在列表渲染中如果修改列表值或者仅仅只是 setState 一个一样的列表, 也会导致真实 dom 被销毁\n索引值: 若使用列表索引作为 key, 在列表顺序被打乱的情况下不会销毁真实 dom, 但可能会导致非受控组件(如 input)互相篡改导致无法预期的变化\n唯一值: 推荐使用唯一值作为 key, 以保证 key 的唯一性和确定性\n\nuseMemo 和 memo 的区别useMemo 和 memo 都可用于缓存组件, 区别在于:\n\nuseMemo 可以缓存状态, memo 是一个 HOC, 只能缓存组件\nuseMemo 需要声明依赖项, memo 默认依赖于组件的 props\n\n组件缓存方式\n使用 React.memo 或 useMemo 来对组件进行缓存\n子组件通过 props.children 来挂载, 能够保证子组件不更新, 这种方式传递给一个组件的子组件实际上是属于父组件的子组件, 所以当前组件更新不会触发这个子组件更新\n\nuseLayoutEffect 与 useEffectuseLayoutEffect 与 useEffect 作用和语法都一样, 区别只有执行时机:\n\nuseEffect 执行在 React 渲染和提交之后, 是异步执行的, 可能会让界面的改动在下一次绘制才生效\nuseLayoutEffect 执行在浏览器绘制之前, 是同步执行的, 会阻塞渲染, 等价于 ComponentDidMount (源码中有调用实例的 ComponentDidMount 钩子), 并且在 ssr 模式下不能使用\n\n总结:\n\n优先使用 useEffect, 因为它是异步不会阻塞渲染\n会影响渲染的操作可以放到 useLayoutEffect 中, 避免闪烁\n不能在 ssr 中使用 useLayoutEffect\n\nuseCallback 作用useCallback 可以缓存函数, 是对于 useMemo 功能的特化\n使用场景想象一个场景, 当有一个 React.memo 创建的子组件, 它的 prop 有一个值为函数, 来自父组件传递, 而这个函数是定义在父组件中的, 那么父组件每次渲染时, 都会创建一个新的函数实例导致子组件不必要的重新渲染, 而 useCallback 就是为了解决这个问题\nuseCallback 不是总会带来性能提升, 应该避免过度优化\n应该使用的场景:\n\n子组件的性能优化: 当将一个函数传递给已经用 React.memo 优化过的子组件时, 使用 useCallback 可以确保子组件不会因为父组件重新渲染导致子组件不必要的重新渲染\nHook 依赖: 若函数被作为其他 hook 的依赖项, 使用 useCallback 可确保函数的稳定性, 可以避免不必要的副作用\n复杂计算和频繁的重新渲染: 如果组件涉及频繁的操作和反馈, 使用 useCallback 可以避免性能问题\n\n不应使用的场景:\n\n不涉及传参和作为依赖的情况\n简单组件\n过度优化: 通常函数组件的重新渲染不会带来明显的性能问题, useCallback 没有必要\n\nuseTransition使用const [isPending, startTransition] = useTransition();startTransition(() =&gt; &#123;  setPage(&quot;/about&quot;);&#125;);\n\n注意点\nuseTransition 在 react 18 中加入, 需要通过 React.createRoot(root).render() 开启并发模式才能使用\nstartTransition 中的函数必须是同步的\n被 useTransition 包裹的同一个状态多次更新, 只会渲染最后一个, 前面的都算中断\n\nuseDefferdValue使用const [value, setValue] = useState();const deferredText = useDeferredValue(value);\n\n特性类似于 useTransition 是可中断的单个状态, 会在其他紧急任务完毕后才执行, 并且每次只渲染最新的结果\n与节流防抖的区别\n主要应用于优化界面的渲染, 不能终止如网络请求等操作\n不用设置固定的延迟时间, 会自动在空闲时间执行\n\n父组件获取子组件的状态和方法的方式\n父组件将 ref 传递给子组件, 子组件用 forwardRef 包裹, 这样可以获取到子组件的元素\n在子组件中使用 useImperativeHandle 返回定义好的属性和方法, 并使用 forwardRef 包裹, 这样父组件就能通过 ref 调用子组件定义好的属性和方法\n\nuseEffect 依赖对象深层比较useEffect 对引用类型的依赖比较是浅比较(Object.is(obj1, obj2) 进行比较), 只要对象指针变化了就会触发副作用, 如果要深层比较对象字面量需要自定义 hooks, 如:\nimport &#123; isEqual &#125; from &quot;lodash&quot;;/** * @param effect 副作用函数 * @param deps 依赖项, 可以是引用类型的值 * @param compare 比较函数, 用于对象深层比较 */const useDeepCompareEffect = (effect, deps, compare) =&gt; &#123;  // 如果没传比较函数, 则默认使用lodash的isEqual  if (!compare) compare = isEqual;  // 标记是否改变  const signal = useRef&lt;number&gt;(0);  const memoizedDeps = useRef&lt;any&gt;([]);  if (deps === undefined || !compare(memoizedDeps.current, deps)) &#123;    signal.current++;  &#125;  // 缓存当前deps  memoizedDeps.current = deps;  useEffect(effect, [signal.current]);&#125;;\n\n高阶组件使用场景\n复用逻辑: HOC 可以帮助我们在组件之间复用逻辑, 避免重复代码, 如带 loading 状态的多个组件可以将 loading 逻辑放入 HOC 来避免在每个组件都声明 loading 状态\n修改 props: HOC 可以修改传递给组件的 props, 从而改变组件的行为, 如利用 HOC 根据权限显示或隐藏某些部分\n条件渲染: 可以根据条件来确定是渲染传入的组件还是其他组件\n提供额外功能: 可以为组件提供额外的功能, 如错误处理, 数据处理, 性能监控等\n\n","categories":["Web"],"tags":["React","React 细节"]},{"title":"React 事件机制原理","url":"/2022/06/15/Web/react-events-system/","content":"React 事件机制原理详细介绍 React 中的合成事件机制和实现原理\n原生事件浏览器基于 W3C 规范实现了一套标准化 DOM 事件, 基于 Event 类实现了常见的用户事件如 InputEvent, MouseEvent 等\n事件发生时, 相关信息会储存在 Event 实例对象中, 包括 currentTarget, detail, target, preventDefault(), stopPropagation() 等属性方法, DOM 节点可以通过 addEventListener 和 removeEventListener 来添加或移除事件监听函数\nReact 合成事件React 在基于原生事件规范的前提下实现了合成事件(Synthetic Events), 合成事件与原生事件不是一一对应关系, 如 onChange 事件就由 change, click, input, keydown, keyup 等原生事件组成\n事件机制事件注册使用 React.createRoot 创建 root 时, React 会调用 listenToAllSupportedEvents 方法对所有支持的原生事件进行监听, 该方法会收集并返回 allNativeEvents, 用于收集所有合成事件相关联的原生事件名, 并且这个收集动作在事件插件初始化阶段就完成了\n随后对每个原生事件调用 addTrappedEventListener 函数, 函数内最终使用 addEventListener 方法对原生事件进行捕获或冒泡阶段的事件监听注册\nfunction addTrappedEventListener(  targetContainer: EventTarget,  domEventName: DOMEventName,  eventSystemFlags: EventSystemFlags,  isCapturePhaseListener: boolean) &#123;  let listener = createEventListenerWrapperWithPriority(    targetContainer,    domEventName,    eventSystemFlags  );  // ...  if (isCapturePhaseListener) &#123;    addEventCaptureListener(targetContainer, domEventName, listener);  &#125; else &#123;    addEventBubbleListener(targetContainer, domEventName, listener);  &#125;&#125;\n\n基于这个流程可知, 调用 React.createRoot 时就已经在 root 节点上初始化了所有原生事件的监听回调函数, 而不是在执行组件函数时才进行注册\n事件触发\n在注册事件阶段调用的 addTrappedEventListener 方法中, 会使用 createEventListenerWrapperWithPriority 函数来创建事件回调. createEventListenerWrapperWithPriority 函数根据事件类型, 划分出若干个不同优先级的 dispathEvent. 事件回调最终都调用进 dispatchEvent 方法\n触发一个事件的执行流程如下:\n\n原生事件触发后进入 dispathEvent 回调方法\nattemptToDispatchEvent 方法根据该原生事件查找到当前 DOM 节点和映射的 Fiber 节点\n事件和 Fiber 等信息被派发给插件系统进行处理, 插件系统调用各插件暴露的 extractEvents 方法\naccumulateSinglePhaseListeners 方法向上收集 Fiber 树上监听相关事件的其他回调函数, 构造合成事件并加入到派发队列 dispatchQueue 中\n调用 processDispatchQueue 方法, 基于捕获或冒泡阶段的标识, 按倒序或顺序执行 dispatchQueue 中的方法\n\n总结React 的事件处理机制可以分为两个阶段, React.createRoot 时在 root 节点上注册原生事件, 原生事件触发时模拟捕获, 目标和冒泡阶段派发合成事件. 通过这种机制, 冒泡的原生事件类型最多在 root 节点上注册一次, 节省了内存开销. 且 React 为不同类型的事件定义了不同的优先级, 让代码及时响应高优先级的用户交互, 提升用户体验\nReact 的合成事件在符合 W3C 规范的前提下抹平了不同浏览器的差异, 并且简化事件逻辑, 对关联事件进行合成\n","categories":["Web"],"tags":["React","事件","原生事件","合成事件","事件机制","事件系统"]},{"title":"Tailwindcss 使用细节整理","url":"/2022/10/08/Web/tailwindcss-details/","content":"Tailwindcss 使用细节整理实际使用中遇到的一些 Tailwindcss 操作的细节和问题的记录\n类名中使用任意值插入动态值有时官方的 utilities 不能满足像素级别的设计, 可以使用方括号的形式直接设置像素值或颜色值等:\n&lt;div class=&quot;w-[125px] h-[64px]&quot;&gt;  &lt;!-- ... --&gt;&lt;/div&gt;&lt;div class=&quot;bg-[#99caff] text-[26px]&quot;&gt;  &lt;!-- ... --&gt;&lt;/div&gt;\n\nTheme 函数调用任意值类名中可以使用 theme 函数来调用任意已定义的设计:\n&lt;div class=&quot;grid grid-cols-[fit-content(theme(spacing.32))]&quot;&gt;  &lt;!-- ... --&gt;&lt;/div&gt;\n\n调用 css 变量将 css 变量作为任意值时, 不需要封装在 var() 函数中, 直接使用变量名即可:\n&lt;div class=&quot;bg-[--custom-color]&quot;&gt;  &lt;!-- ... --&gt;&lt;/div&gt;\n\n任意属性方括号还可以像写内联样式一样编写任意 css 属性和值\n&lt;div class=&quot;[mask-type:luminance]&quot;&gt;  &lt;!-- ... --&gt;&lt;/div&gt;&lt;!-- 可以使用 css 修饰符 --&gt;&lt;div class=&quot;[top:120px] hover:[top-200px]&quot;&gt;  &lt;!-- ... --&gt;&lt;/div&gt;\n\n处理歧义Tailwindcss 会根据传入的值自动处理有歧义的值, 如共用 text- 的颜色和大小:\n&lt;div class=&quot;text-[#99caff] text-[26px]&quot;&gt;  &lt;!-- ... --&gt;&lt;/div&gt;\n\n但如果使用 css 变量时可能会无法分别这种歧义, 这时可以在值前添加 css 数据类型来进行区分:\n&lt;!-- Will generate a font-size utility --&gt;&lt;div class=&quot;text-[length:var(--my-var)]&quot;&gt;...&lt;/div&gt;&lt;!-- Will generate a color utility --&gt;&lt;div class=&quot;text-[color:var(--my-var)]&quot;&gt;...&lt;/div&gt;\n\n类名检测注意事项在 js 中操作类名当在 js 中进行了 tailwindcss 类名的操作时, 需要将 js 文件也作为监测对象配置在 content 中, 如:\nbtn.addEventListener(&quot;click&quot;, function () &#123;  const div = document.getElementById(&quot;myDiv&quot;);  div.setAttribute(&quot;class&quot;, &quot;bg-red-100&quot;);&#125;);\n\n若 tailwindcss 没有配置 js 内容文件, 则这个类名可能不会生效, 需要在 tailwindcss.config.js 中进行配置:\n/** @type &#123;import(&#x27;tailwindcss&#x27;).Config&#125; */module.exports = &#123;  content: [    // ...    &quot;./src/**/*.js&quot;,  ],  // ...&#125;;\n\n不要使用动态类名尽量不要使用动态类名, 如:\nfunction (props) &#123;  return &lt;div className=&#123;`text-$&#123;props.error ? &#x27;red&#x27; : &#x27;green&#x27;&#125;`&#125;&gt;&lt;/div&gt;&#125;// 优先使用完整类名function (props) &#123;  return &lt;div className=&#123;props.error ? &#x27;text-red&#x27; : &#x27;text-green&#x27;&#125;&gt;&lt;/div&gt;&#125;\n\n安全列表和丢弃类如果使用动态类名, 可以在安全列表中将用到的类名提前加入该类名:\n/** @type &#123;import(&#x27;tailwindcss&#x27;).Config&#125; */module.exports = &#123;  content: [    // ...  ],  safelist: [    &quot;bg-red-500&quot;,    &quot;text-3xl&quot;,    &quot;lg:text-4xl&quot;,    // 安全列表还支持正则表达式    &#123;      pattern: /bg-(red|green|blue)-(100|200|300)/,      variants: [&quot;lg&quot;, &quot;hover&quot;, &quot;focus&quot;, &quot;lg:hover&quot;],    &#125;,  ],  // ...&#125;;\n\n与之相对的还有丢弃类, 表示即便一个类名被 tailwindcss 检测到也不会生成在产物中:\n/** @type &#123;import(&#x27;tailwindcss&#x27;).Config&#125; */module.exports = &#123;  content: [    // ...  ],  // 不能使用正则表达式  blocklist: [&quot;container&quot;],  // ...&#125;;\n\n配置主题在 theme 配置中可以定制各种 css 属性, 同时覆盖或扩展现有主题:\n/** @type &#123;import(&#x27;tailwindcss&#x27;).Config&#125; */module.exports = &#123;  theme: &#123;    colors: &#123;      primary: &quot;#0933ff&quot;,    &#125;,    extend: &#123;      screens: &#123;        &quot;3xl&quot;: &quot;1600px&quot;,      &#125;,    &#125;,  &#125;,&#125;;\n\n在项目中可以使用这些值:\n&lt;div class=&quot;text-primary md:text-md 3xl:text-lg&quot;&gt;Hola&lt;/div&gt;\n\n详细可配置项参阅主题\n引用主题其他值或默认主题/** @type &#123;import(&#x27;tailwindcss&#x27;).Config&#125; */const defaultTheme = require(&quot;tailwindcss/defaultTheme&quot;);module.exports = &#123;  theme: &#123;    fill: (&#123; theme &#125;) =&gt; (&#123;      gray: theme(&quot;colors.gray&quot;), // 使用链式调用获取实际值    &#125;),    extend: &#123;      fontFamily: &#123;        sans: [&quot;Lato&quot;, ...defaultTheme.fontFamily.sans], // 获取默认主题的值      &#125;,    &#125;,  &#125;,&#125;;\n\n插件可用于注册新样式, 包括工具类, 基础样式, 组件等\n基本语法:\nconst plugin = require(&quot;tailwindcss/plugin&quot;);module.exports = &#123;  theme: &#123;    borderRadius: &#123;      sm: &quot;4px&quot;,    &#125;,  &#125;,  plugins: [    plugin(function (&#123;      addUtilities,      addComponents,      addBase,      addVariant,      theme,    &#125;) &#123;      // 添加静态工具类      addUtilities(&#123;        &quot;.content-auto&quot;: &#123;          &quot;content-visibility&quot;: &quot;auto&quot;,        &#125;,      &#125;);      // 添加组件      addComponents(&#123;        &quot;.btn&quot;: &#123;          background: &quot;blue&quot;,          color: &quot;#fff&quot;,          // theme 函数可以引用其他配置值          &quot;border-radius&quot;: theme(&quot;borderRadius.sm&quot;),          // 可直接使用伪类          &quot;&amp;:hover&quot;: &#123;            background: &quot;gray&quot;,          &#125;,        &#125;,      &#125;);      // 添加基础样式      addBase(&#123;        h1: &#123;          fontSize: &quot;32px&quot;,        &#125;,      &#125;);      // 添加变体      addVariant(&quot;optional&quot;, &quot;&amp;:optional&quot;);      addVariant(&quot;hocus&quot;, [&quot;&amp;:hover&quot;, &quot;&amp;:focus&quot;]);      addVariant(&quot;inverted-colors&quot;, &quot;@media (inverted-colors: inverted)&quot;);    &#125;),  ],&#125;;\n","categories":["Web"],"tags":["Tailwindcss","Tailwindcss 细节"]},{"title":"用tauri将前端页面打包成桌面应用","url":"/2022/04/02/Web/tauri-pack-web-app/","content":"tauri 介绍Tauri 是一款使用 rust 开发的应用构建工具包, 让你能够为使用 Web 技术的所有主流桌面操作系统构建软件\n安装 tauriwindows\n安装 rust\n前往https://www.rust-lang.org/zh-CN/tools/install下载并安装 rust 运行环境\n\n在项目中加入 tauri\n安装 tauri cli 工具, 并执行创建命令\npnpm add -D @tauri-apps/clipnpm tauri init\n\n接下来 tauri 会向你提出几个问题, 回答之后会在你的项目根目录加入一个 src-tauri 文件夹, 其中包含了 tauri 的核心运行代码和配置文件, 比较关键的文件如下:\n\nCargo.toml\nCargo 清单, 声明了当前应用依赖的 rust 包和元数据等内容\n\ntauri.conf.json\n项目构建配置文件, 可高度自定义 tauri 应用的各方面, 可参考Tauri 的 API 配置\n\nsrc&#x2F;main.rs\nrust 程序入口, 其中的 main 函数就是运行时的入口函数\n\n\n\n开发环境\n在 tauri.conf.json 中可以配置开发环境监听的本地端口和开启开发环境之前需要执行的命令(如一些项目中通常会执行 pnpm dev 来开启本地开发环境)\n&#123;  &quot;build&quot;: &#123;    &quot;beforeDevCommand&quot;: &quot;pnpm dev&quot;,    &quot;devPath&quot;: &quot;http://localhost:8888&quot;  &#125;&#125;\n\n执行上述步骤后, 现在你可以执行以下命令来开启开发环境\npnpm tauri dev\n\n执行完毕后会打开一个窗口, 此时就能看到你的前端界面了\n\n打包应用\n打包之前需要先进行一些配置, 比如配置构建应用之前需要执行的打包操作, 以及打包好的文件输出的目录:\n&#123;  &quot;build&quot;: &#123;    &quot;beforeBuildCommand&quot;: &quot;pnpm build:pack&quot;,    &quot;distDir&quot;: &quot;../dist&quot;  &#125;&#125;\n\n应用打包后的名称和版本:\n&#123;  &quot;package&quot;: &#123;    &quot;productName&quot;: &quot;myApp&quot;,    &quot;version&quot;: &quot;0.1.0&quot;  &#125;&#125;\n\n以及窗口相关的配置, 具体配置可参考Tauri 的 API 配置\n打包命令\npnpm tauri build\n\n打包成功后可以在项目中的 src-tauri&#x2F;target&#x2F;release 目录中找到应用的可执行文件\n\n打包时的错误处理\n墙内使用 tauri 打包时可能会遇到一些 github 上的资源下载失败的问题\n\nDownloading https://github.com/wixtoolset/wix3/releases/download/wix3112rtm/wix311-binaries.zip\n墙内由于访问 github 非常慢, 下载依赖包大概率失败, 解决办法是直接去下载这个 zip 包, 随后将其中所有文件解压到 C:\\Users\\用户\\AppData\\Local\\tauri\\WixTools 这个目录中, 如果不存在这个目录则手动创建一个\n\nDownloading https://github.com/tauri-apps/binary-releases/releases/download/nsis-3/nsis-3.zip\n同理, 这个从 github 上下载的依赖包也大概率失败, 直接下载 zip 包将所有文件解压到 C:\\Users\\用户\\AppData\\Local\\tauri\\NSIS 中\nNSIS3 中还有两个依赖的插件会从 github 自动下载, 如果构建应用时下载失败, tauri 会自动删除本地的 NSIS 包\n所以我们还需要手动去下载 NSIS3 依赖的两个插件, 其下载地址如下:\n\nhttps://github.com/tauri-apps/binary-releases/releases/download/nsis-plugins-v0/NSIS-ApplicationID.zip\nhttps://github.com/tauri-apps/nsis-tauri-utils/releases/download/nsis_tauri_utils-v0.1.1/nsis_tauri_utils.dll\n\n其中, NSIS-ApplicationID.zip 包将其解压后, 复制目录中的 release\\ApplicationID.dll 文件到 C:\\Users\\用户\\AppData\\Local\\tauri\\NSIS\\Plugins\\x86-unicode 目录中, nsis_tauri_utils.dll 下载完成后同样复制到这个目录中, 随后再次执行 tauri build 就能正常打包出可执行文件了\n\n\n\n\n","categories":["Web"],"tags":["Rust","Tauri","前端应用","桌面应用"]},{"title":"tcp 和 http 的联系","url":"/2022/04/22/Web/tcp-and-http/","content":"tcp 和 http 的联系详细介绍 tcp 和 http 协议的区别和联系\n开放系统互联(OSI)开放系统互联(Open System Interconnection)是国际计算机通信标准, 其中将网络分为 7 层\n\n物理层 -&gt; 2. 数据链路层 -&gt; 3. 网络层 -&gt; 4. 传输层 -&gt; 5. 会话层 -&gt; 6. 表示层 -&gt; 7. 应用层\n\n\n\n\n层级\n协议\n描述\n\n\n\n7\n应用层\n主要协议有: http, ftp, dns, ssh 等\n\n\n6\n表示层\n将数据转为可理解的语法和语义\n\n\n5\n会话层\n维护网络连接状态, 保持会话同步, 有 ssl 协议\n\n\n4\n传输层\n提供进程间数据传输服务, 主要有 tcp 和 udp\n\n\n3\n网络层\n负责将数据独立地从信源发送到信宿, 主要是 IP\n\n\n2\n数据链路层\n负责将数据封装成适合在网络上传播的帧格式并传输\n\n\n1\n物理层\n负责在节点间传播比特流, 即物理传输\n\n\n传输层协议传输层主要有 tcp 和 udp 两个传输协议\nTCP\n面向连接\n每一个 tcp 都是一对一的\n提供可靠交付服务\n提供全双工通信\n面向字节流\n\n使用 tcp 协议时, 客户端和服务端之间要先建立一个连接, 在进行实际读写操作, 读写完成后双方不再需要这个连接时, 就会释放这个连接, 建立连接需要三次握手, 释放连接需要四次挥手\nUDP\n无连接\n尽最大努力交付\n面向报文\n无拥塞控制\n支持一对一, 一对多, 多对一, 多对多\n首部开销小\n\n三次握手\n第一次握手, 客户端向服务端发送建立连接的请求报文, 发送后则进入 SYN_SENT 状态\n第二次握手, 服务端收到请求报文后如果同意连接, 则发送一个确认应答, 随后进入 SYN_RCVD 状态\n第三次握手, 客户端收到应答报文后, 再向服务端发送一个确认报文, 随后进入 ESTABLISHED 状态, 服务端收到确认报文后也进入 ESTABLISHED 状态\n\n四次挥手\n第一次挥手, 客户端认为数据发送完成, 则需要向服务端发送释放连接请求\n第二次挥手, 服务端收到请求后, 会发送一个 ACK 包, 并确认数据是否已传输完毕, 同时进入 CLOSE_WAIT 状态\n第三次挥手, 服务端确认数据传输完毕, 向客户端发送释放连接请求, 同时进入 LAST_ACK 状态\n第四次挥手, 客户端收到释放请求后, 向服务端发送一个确认应答并进入 CLOSED 状态, 服务端收到应答后也进入 CLOSED 状态\n\n应用层协议HTTPhttp 是建立在 tcp 之上的应用层协议, 超文本传输协议\nhttp 连接最显著的特点是客户端发送的每次请求都需要服务器回送响应, 在请求结束后, 会主动释放连接.从建立连接到关闭连接的过程称为一次连接.\nhttp1.0 :客户端的每次请求都要求建立一次单独的连接, 在处理完本次请求后, 就自动释放连接.\nhttp1.1 ：可以在一次连接中处理多个请求, 并且多个请求可以重叠进行, 不需要等待一个请求结束后就可以再发送一个新的请求\nhttp2.0 ：支持多路复用, 一个 TCP 可同时传输多个 http 请求, 头部数据还做了压缩\nhttp3.0 ：使用了 QUIC, 开启多个 TCP 连接, 在出现丢包的情况下, 只有丢包的 TCP 等待重传, 剩余的 TCP 连接还可以正常传输数据\nHTTP 特性\n无状态, 不能记忆数据\n无连接\n基于请求和响应\n明文通信\n\nHTTP 的组成\n请求行: url, method, http 协议和版本\n请求头: 请求信息组成的键值对\n空行: 表示请求头结束, 之后的内容是请求体\n请求体: 数据部分\n\n","categories":["Web"],"tags":["http","tcp","协议"]},{"title":"Vue3 细节整理","url":"/2022/05/02/Web/vue3-details/","content":"Vue3 细节整理实际使用中遇到的一些 Vue3 操作的细节和问题的记录\nreactive 的局限\n只能用于对象类型(object, array, Map, Set 等), 不能用于原始值类型 (boolean, number, string 等), 因为 Proxy 只能作用于对象结构\n不能替换整个对象, 必须始终保持响应式对象的相同引用\n结构后对象属性会失去响应式特性\n\nref 特性\nref 会将任意类型包装成一个 Proxy 对象, 通过内部的 value 属性挂载实际值\n如果传递原始数据类型, 则 ref 本身是一个 RefImpl 对象, 而 value 是原始值, 如果传递引用数据类型, 则 value 会包装成 Proxy 对象\nref 变量作为顶层属性时可以自动解包, 如 const count &#x3D; ref(0), 在模板中应用时 {count}, 而引用数据类型则不能自动解包, 如 const person &#x3D; ref({ age: 2 }), 在模板中 {person.age} 无法正确获取到值, 需要手动解包, 如 const { age } &#x3D; person\n\n父子组件执行顺序父 setup -》 父 onBeforeMount &#x3D;〉子 setup -》子 onBeforeMount -〉子 onMounted -》 父 onMounted\nwatch 深层监听\n当传递一个响应式对象给 watch 而不是一个 getter 函数时, watch 会自动创建响应式对象的深层监听, 如:\n\nconst obj = reactive(&#123;  inner: &#123;    count: 10,  &#125;,&#125;);const addObjCount = () =&gt; &#123;  obj.inner.count++;&#125;;// 此时修改 count 时会触发 watch 回调函数watch(obj, (newValue, oldValue) =&gt; &#123;  console.log(&quot;新的 obj:&quot;, newValue.inner);  console.log(&quot;旧的 obj:&quot;, oldValue.inner);&#125;);// 等价于// watch(//   () =&gt; obj,//   (newValue, oldValue) =&gt; &#123;//     console.log(&quot;新的 obj:&quot;, newValue.inner);//     console.log(&quot;旧的 obj:&quot;, oldValue.inner);//   &#125;,//   &#123;//     deep: true,//   &#125;// );\n\n此时绑定 addObjCount 函数到点击事件, 会发现每次点击都触发了 watch 回调函数执行, 而修改 watch 的参数为 getter 函数后, 则不会触发\n// 此时修改 count 时不会触发 watch 回调函数watch(  () =&gt; obj,  (newValue, oldValue) =&gt; &#123;    console.log(&quot;新的 obj:&quot;, newValue.inner);    console.log(&quot;旧的 obj:&quot;, oldValue.inner);  &#125;);\n\nwatch 和 watchEffect 区别\nwatch 需要指明监听对象, watchEffect 隐式监听回调函数中的响应式数据\nwatch 只有在数据变化时执行回调函数, watchEffect 会在响应式数据初始化时就执行回调函数\n\nwatch &#x2F; watchEffect 回调函数执行时机默认情况下, 监听回调执行时机是在 vue 组件渲染到 dom 之前, 如果设置了 flush: ‘post’ 则是在渲染之后执行, 可以获取到更新后的 dom\nv-show 和 v-if 异同共同点:\n\n控制元素是否显示在界面\n为 true 时会占据页面位置, 为 false 时不会占据\n都会导致回流(reflow)和重绘(repaint)\n\n不同点:\n\nv-show 无论何值都会渲染元素, 但使用 css display 属性来控制显示隐藏, v-if 为 false 则是直接不渲染元素\nv-show 由 false 变为 true 不会触发生命周期, v-if 由 false 变为 true 会触发 create 和 mount 阶段的生命周期钩子, true 改为 false 则会触发 destroy 阶段的钩子\nv-if 有更高的切换性能消耗, v-show 则是更高的初始渲染消耗\n\nv-for 中的 keyVue 在处理更新同类型 vnode 的一组子节点的过程中, 为了减少 DOM 频繁创建和销毁的性能开销\n假设要更新这样一个节点列表\n\n\n对没有 key 的子节点数组更新调用的是 patchUnkeyedChildren 这个方法, 核心是就地更新的策略. 它会通过对比新旧子节点数组的长度, 先以比较短的那部分长度为基准, 将新子节点的那一部分直接 patch 上去. 然后再判断, 如果是新子节点数组的长度更长, 就直接将新子节点数组剩余部分挂载(mount); 如果是新子节点数组更短, 就把旧子节点多出来的那部分给卸载掉(unmount). 所以如果子节点是组件或者有状态的 DOM 元素, 原有的状态会保留, 就会出现渲染不正确的问题\n\n\n\n有 key 的子节点更新是调用的 patchKeyedChildren, 这个函数就是大家熟悉的实现核心 diff 算法的地方, 大概流程就是同步头部节点, 同步尾部节点, 处理新增和删除的节点, 最后用求解最长递增子序列的方法去处理未知子序列. 是为了最大程度实现对已有节点的复用, 减少 DOM 操作的性能开销, 同时避免了就地更新带来的子节点状态错误的问题\n\n\n如果是用 v-for 去遍历常量或者子节点是诸如纯文本这类没有状态的节点, 是可以使用不加 key 的写法的。但是实际开发过程中更推荐统一加上 key, 能够实现更广泛场景的同时, 避免了可能发生的状态更新错误, 我们一般可以使用 ESlint 配置 key 为 v-for 的必需元素\n通常在数据量大的列表等情况下推荐给元素加上 key, 可以有效减少 diff 的开销, 因为没有 key, 算法需要进入子节点深入比较变化, 加上 key 可以最大程度复用节点, 进行节点位置的移动而不是频繁销毁和创建新的节点\nvue3 中的宏命令宏是一种特殊代码, 运行在编译阶段, 会被编译器转换成其他代码, 实际上是一种巧妙地字符串替换技巧, 根据功能不同, 转换后的代码也不同\n为什么宏不用 importimport 的模块在运行时执行, 编译时执行的宏命令不需要 import\n注意点编译时只会处理 setup 顶层的宏, 被包裹在代码块中的宏不会被编译器转换, 导致在运行时执行这些代码时报错\nnextTick在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法, 获取更新后的 DOM\n用法import &#123; createApp, nextTick &#125; from &quot;vue&quot;;const app = createApp(&#123;  setup() &#123;    const message = ref(&quot;Hello!&quot;);    const changeMessage = async (newMessage) =&gt; &#123;      message.value = newMessage;      // 这里获取DOM的value是旧值      await nextTick();      // nextTick 后获取DOM的value是更新后的值      console.log(&quot;Now DOM is updated&quot;);    &#125;;  &#125;,&#125;);\n\n特性\n如果你想捕捉组件数据变化后 DOM 更新的时刻, 那么你需要使用 nextTick(callback) 函数\n它们的单个 callback 参数在 DOM 更新后立即被调用: 并且你可以保证获得与组件数据同步的最新 DOM\n或者, 如果你不向 nextTick() 提供回调参数, 那么这些函数将返回一个在 DOM 更新时被解析的 promise\n\nh 函数返回一个”虚拟节点”, 通常缩写为 VNode: 一个普通对象, 其中包含向 Vue 描述它应该在页面上呈现哪种节点的信息, 包括对任何子节点的描述, 用于手动编写 render\nh 接受三个参数\n\ntype 元素类型\npropsOrChildren 数据对象, 如 props, domProps, class, attrs, style 等\nchildren 子节点\n\n通过内部的 _createVNode 方法生成 VNode 虚拟节点\n","categories":["Web"],"tags":["Vue3","Vue3 细节"]},{"title":"Web 端跨域详解","url":"/2022/04/30/Web/web-cross-domain/","content":"Web 端跨域详解详细介绍 Web 端的跨域问题\n跨域三种情况当网络请求出现以下情况时, 就属于跨域请求:\n\n协议不同, 如 http 和 https\n域名不同\n端口不同\n\n原理跨域问题本质上是浏览器行为, 初衷是用于保护用户的访问安全, 属于浏览器同源策略的体现, 这是浏览器最核心和基础的安全功能, 同源策略的限制有以下几种:\n\nCookie、LocalStorage 和 IndexDB 无法读取\nDOM 和 JS 对象无法获得\nAJAX 请求不能发送\n\n解决跨域JSONP\n原理就是利用 script 标签没有跨域限制, 通过 src 属性设置包含 callback 参数的跨域 GET 请求, 服务端接口将返回数据拼凑到 callback 函数中返回给浏览器, 从而让前端拿到在 callback 函数中获取的数据\n\n&lt;script&gt;  var script = document.createElement(&quot;script&quot;);  script.type = &quot;text/javascript&quot;;  // 传参一个回调函数名给后端, 方便后端返回时执行这个在前端定义的回调函数  script.src =    &quot;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&quot;;  document.head.appendChild(script);  // 回调执行函数  function handleCallback(res) &#123;    alert(JSON.stringify(res));  &#125;&lt;/script&gt;\n\nJSONP 的缺点是只能发送 GET 请求\n跨域资源共享(CORS)CORS 是一个 W3C 标准, 它允许浏览器向跨域服务器发送 XHR 请求以客服 AJAX 的同源限制, 需要前后端同时支持\nCORS 分为简单请求和非简单请求, 如果请求同时满足以下两个条件则是简单请求:\n\n请求方式\n\n\n\nget\n\n\n\npost\n\n\n\nhead\n\n\n\n\n请求头\n\n\n\nAccept\n\n\n\nAccept-Language\n\n\n\nContent-Language\n\n\n\nContent-Type 仅限于三个值: application&#x2F;x-www-form-urlencoded, multipart&#x2F;form-data, text&#x2F;plain\n\n\n\n若没有同时满足以上两个条件就属于非简单请求\n简单请求发送简单请求时, 浏览器在头信息中增加一个 Origin 字段, 用来说明请求来源(协议 + 域名 + 端口), 服务端根据这个 Origin 来决定是否同意这次请求\nCORS 请求设置响应头字段, 都以 Access-Control-开头:\n\nAccess-Control-Allow-Origin: 必选\n\n\n它的值要么是请求时 Origin 字段的值, 要么是一个*, 表示接受任意域名的请求\n\n\nAccess-Control-Allow-Credentials: 可选\n\n\n它的值是一个布尔值, 表示是否允许发送 Cookie. 默认情况下, Cookie 不包括在 CORS 请求之中. 设为 true, 即表示服务器明确许可, Cookie 可以包含在请求中, 一起发给服务器. 这个值也只能设为 true, 如果服务器不要浏览器发送 Cookie, 删除该字段即可\n\n\nAccess-Control-Expose-Headers: 可选\n\n\nCORS 请求时, XMLHttpRequest 对象的 getResponseHeader()方法只能拿到 6 个基本字段: Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma. 如果想拿到其他字段, 就必须在 Access-Control-Expose-Headers 里面指定. 上面的例子指定, getResponseHeader(‘FooBar’)可以返回 FooBar 字段的值\n\n非简单请求非简单请求是那种对服务器有特殊要求的请求, 如请求方法是 PUT 或 DELETE, 或者 Content-Type 字段值为 application&#x2F;json 等. 非简单请求会在正是通信前增加一次 http 查询请求, 称为预检请求(preflight)\n预检请求的请求方法为 OPTIONS, 表示用于询问, 请求头里除了需要包含 Origin, 还需要包含两个字段:\n\nAccess-Control-Request-Method: 必选\n\n\n用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法, 如 PUT\n\n\nAccess-Control-Request-Headers: 可选\n\n\n该字段是一个逗号分隔的字符串, 指定浏览器 CORS 请求会额外发送的头信息字段, 如 X-Custom-Header\n\n服务器收到预检请求后, 检查了这些字段后, 确认允许跨源请求, 就可以做出回应, 响应头中除了 Access-Control-Allow-Origin 外, 还有其他 CORS 相关字段:\n\nAccess-Control-Allow-Methods: 必选\n\n\n它的值是逗号分隔的一个字符串, 表明服务器支持的所有跨域请求的方法。注意, 返回的是所有支持的方法, 而不单是浏览器请求的那个方法, 这是为了避免多次预检请求\n\n\nAccess-Control-Allow-Headers\n\n\n如果浏览器请求包括 Access-Control-Request-Headers 字段, 则 Access-Control-Allow-Headers 字段是必需的, 它也是一个逗号分隔的字符串, 表明服务器支持的所有头信息字段, 不限于浏览器在预检中请求的字段\n\n\nAccess-Control-Allow-Credentials: 可选\n\n\n该字段与简单请求时的含义相同\n\n\nAccess-Control-Max-Age: 可选\n\n\n用来指定本次预检请求的有效期, 单位为秒\n\n代理跨域通过启动一个代理服务器作为浏览器和服务器之间的中间服务来跨域, 如用 nginx 配置一个与前端同源的代理服务器, 将请求转发给真实的服务器实现反向代理\ndocument.domain 和 iframe此方案仅限主域相同, 子域不同的跨域应用场景, 实现原理: 两个页面都通过 js 强制设置 document.domain 为基础主域, 就实现了同域\n&lt;!-- 父窗口 --&gt;&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  document.domain = &quot;domain.com&quot;;  var user = &quot;admin&quot;;&lt;/script&gt;&lt;!-- 子窗口 --&gt;&lt;script&gt;  document.domain = &quot;domain.com&quot;;  // 获取父窗口中变量  console.log(&quot;get js data from parent ---&gt; &quot; + window.parent.user);&lt;/script&gt;\n\npostMessage 跨域postMessage 是 H5 的 api, 主要用于解决以下问题:\n\n页面和其打开的新窗口之间的消息传递\n多窗口之间消息传递\n页面与嵌套的 iframe 的消息传递\n以上场景的跨域消息传递\n\npostMessage(data,origin)方法接受两个参数:\n\ndata: html5 规范支持任意基本类型或可复制的对象, 但部分浏览器只支持字符串, 所以传参时最好用 JSON.stringify()序列化\norigin: 协议+主机+端口号, 也可以设置为”*“, 表示可以传递给任意窗口, 如果要指定和当前窗口同源的话设置为”&#x2F;“\n\n&lt;!-- a.html --&gt;&lt;iframe  id=&quot;iframe&quot;  src=&quot;http://www.domain2.com/b.html&quot;  style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  var iframe = document.getElementById(&quot;iframe&quot;);  iframe.onload = function () &#123;    var data = &#123;      name: &quot;aym&quot;,    &#125;;    // 向domain2传送跨域数据    iframe.contentWindow.postMessage(      JSON.stringify(data),      &quot;http://www.domain2.com&quot;    );  &#125;;  // 接受domain2返回数据  window.addEventListener(    &quot;message&quot;,    function (e) &#123;      alert(&quot;data from domain2 ---&gt; &quot; + e.data);    &#125;,    false  );&lt;/script&gt;&lt;!-- b.html --&gt;&lt;script&gt;  // 接收domain1的数据  window.addEventListener(    &quot;message&quot;,    function (e) &#123;      alert(&quot;data from domain1 ---&gt; &quot; + e.data);      var data = JSON.parse(e.data);      if (data) &#123;        data.number = 16;        // 处理后再发回domain1        window.parent.postMessage(          JSON.stringify(data),          &quot;http://www.domain1.com&quot;        );      &#125;    &#125;,    false  );&lt;/script&gt;\n\nWebSocket 跨域WebSocket protocol 是 HTML5 的一种协议, 它实现了浏览器与服务器全双工通信, 同时允许跨域通讯, 是 server push 技术的一种很好的实现\n","categories":["Web"],"tags":["http","跨域","https","域名","端口"]},{"title":"用metamask创建你的web3身份","url":"/2022/04/15/Web3/create-web3-identity/","content":"用 metamask 创建你的 web3 身份介绍如何使用 metamask 创建你的第一个 web3 身份和数字钱包\nWeb3 简述Web3 网络是指 Web 的下一个版本, 它被设计为一个去中心化的 Web, 旨在提供更多的隐私、安全和用户控制权。Web3 网络的核心概念是去中心化, 即不再依赖中心化的服务器和平台, 而是通过去中心化的协议和技术来实现 Web 的功能, 将为用户带来更多的隐私, 安全和数据控制权\nMetamask 简述Metamask 是一款用于访问以太坊区块链上去中心化应用的浏览器插件, 绝大多数 Web3 项目都支持 Metamask\n创建第一个 web3 身份创建一个 web3 身份有以下 3 步:\n\n安装 Metamask 浏览器插件\n使用 Metamask 创建 web3 身份\n备份 Metamask 账户\n\n第一步: 安装 Metamask 浏览器插件使用 Chrome 访问Metamask 官方网站, 点击 Download to Chrome 按钮跳转至 Chrome 插件商店, 随后点击添加至 Chrome 即可\n第二步: 创建 Metamask 账户安装完成 Metamask 插件后, 会自动跳转到插件界面中, 此时会自动进入账户创建流程, 输入密码, 并记录下助记词, 再次输入助记词后账户创建成功\n第三步: 备份 Metamask 账户第一次创建账户时默认会备份, 将密码和助记词等放入密码管理工具中或直接写在笔记本上, 保存在电脑上时最好进行加密储存\nMetamask 界面\n现在, 你已经拥有了一个 web3 身份, 这是 Metamask 的界面\n左上角的是当前连接的网络选择, 当前连接的是以太坊主网\n顶部是你的账号地址\n0 ETH 是指你当前账户余额\n总结在创建 web3 身份的过程中, 没有任何的身份验证, 这意味着你的身份在 web3 的世界中是被隐藏的, 这创造了空前的自由, 也没有任何的法律或道德, 所以在 web3 的世界中你不能相信任何人, 需要时刻保护自己\n","categories":["Web3"],"tags":["Metamask","Web3","Web3身份","数字钱包"]},{"title":"Web3 开发者需要用到的工具和技术","url":"/2024/06/14/Web3/web3-development-tools/","content":"Web3 开发者需要用到的工具和技术作为一名 web3 开发者在开发中必须要使用和掌握的技术和工具\nWeb3 和 Dapp广义的 Web3 的定义很宽泛, 是一种可读, 可写, 可拥有的互联网, 涵盖了区块链, AI, 大数据, 分布式系统, 去中心化自治组织(DAO), 元宇宙等, Dapp 应用只是其中之一, 而狭义的 web3 差不多就等同于 Dapp 应用\nDapp 是 web3 范畴的产品, 也就是去中心化应用, 使用了区块链技术来达成去中心化\nDapp 系统架构graph TDA[用户] --&gt; D[Dapp]B[用户] --&gt; DC[用户] --&gt; DD --&gt; F[Server]D --&gt; E[智能合约]G[预言机] --&gt; |提供辅助数据|E\n\n第一部分: Dapp运行在浏览器里的 web 应用, 等于 web2 的前端, 但需要对接智能合约\n第二部分: Server和传统 web server 差不多, 与 Dapp 交互, 负责数据库读写, 提供和处理数据, 以及一些业务逻辑的处理\n智能合约智能合约是运行在区块链上的一段二进制代码, 以太坊上的智能合约通常用 Solidity 开发, 编译后上传到以太坊的 EVM 区块链上运行, 又称作链端, 可供 Dapp 调用\n预言机涉及到一些 Dapp 的特殊场景, 需要一些辅助的数据才能完成整个工作的闭环, 此时则需要预言机或 Graph 等提供数据, 如赌球的场景需要预言机提供比赛结果到智能合约\n开发所需工具Metamask官网访问地址: https://metamask.io\n小狐狸钱包(Metamask)是 web3 从业者必备工具之一, 它提供了管理数字资产所需的一切功能\nMetamask 是一个浏览器插件, 大部分主流浏览器都能安装使用\n如何用 metamask 创建你的 web3 身份\nGanache 个人区块链官网下载地址: https://trufflesuite.com/ganache\n对开发者来说, 开发和调试程序时不可能在真实环境中进行, 因为区块链操作都需要消耗金钱, 而且也不安全\n为解决这个痛点, Ganache 应运而生, 它模拟了以太坊主链的所有功能, 可以快速搭建一个本地区块链, 为开发者提供了一个近似的环境调试程序\nRemix 编译工具官网访问地址: https://remix.ethereum.org\nRemix 是智能合约编译部署工具, 可以将 Solidity 开发的智能合约编译成二进制代码并上传到区块链\nRemix 可以在线使用, 无需安装, 并且非常简单直观\nTruffle 和 HardHat 集成化环境官网访问地址: https://trufflesuite.com官网访问地址: https://hardhat.org\n这两个工具都提供了 DAPP 开发, 测试和部署的集成化环境, Ganache 就是 Truffle 的套件之一, 其中 HardHat 的集成度更高更受欢迎\n开发所需技术web3.js 和 ethers.jsweb3.js 专注于与区块链节点的交互, 提供了交互所需的对象和函数, Dapp 前端和链端通常会使用 web3.js 来连接以太坊网络ethers.js 与 web3.js 类似, 但更加轻量和易于使用, 相比于 web3.js 更受欢迎\nweb3-react.jsweb3-react 是一个基于 react hooks, 提供钱包, 账户,网络,事件订阅等状态管理功能, 提供连接器(connectors)来连接多种钱包, 可以在 react 项目中快速集成登录,认证和状态同步的场景\n","categories":["Web3"],"tags":["React","Metamask","Web3","Dapp","以太坊","Solidity","Ganache"]},{"title":"React Fiber","url":"/2022/06/15/Web/react-fiber/","content":"React Fiber详细介绍 React 中的 fiber 机制和原理\n什么是 FiberFiber 就是一个 js 对象, 用于描述一个 react 工作单元. 早期的 react 中是使用虚拟 DOM 来进行描述, 现在的 fiber 架构中则是用 fiber, fiber 可以理解为一个更强大的虚拟 DOM\n一个简化的 fiber 对象如下:\n&#123;  type: &#x27;h1&#x27;,  // 组件类型  key: null,   // React key  props: &#123; ... &#125;, // 输入的props  state: &#123; ... &#125;, // 组件的state (如果是class组件或带有state的function组件)  child: Fiber | null,  // 第一个子元素的Fiber  sibling: Fiber | null,  // 下一个兄弟元素的Fiber  return: Fiber | null,  // 父元素的Fiber  // ...其他属性&#125;\n\nReact 工作时, 会沿着 fiber 树形结构进行, 对比每个 fiber 旧的 props 和新的 props 来确定是否需要更新组件, 如果主线程有更重要的工作, 如响应用户输入, 则可以中断当前工作并返回主线程上的任务\nFiber 结构function FiberNode(  this: $FlowFixMe,  tag: WorkTag,  pendingProps: mixed,  key: null | string,  mode: TypeOfMode) &#123;  // 基本属性  this.tag = tag; // 描述此Fiber的启动模式的值（LegacyRoot = 0; ConcurrentRoot = 1）  this.key = key; // React key  this.elementType = null; // 描述React元素的类型。例如，对于JSX&lt;App /&gt;，elementType是App  this.type = null; // 组件类型  this.stateNode = null; // 对于类组件，这是类的实例；对于DOM元素，它是对应的DOM节点。  // Fiber链接  this.return = null; // 指向父Fiber  this.child = null; // 指向第一个子Fiber  this.sibling = null; // 指向其兄弟Fiber  this.index = 0; // 子Fiber中的索引位置  this.ref = null; // 如果组件上有ref属性，则该属性指向它  this.refCleanup = null; // 如果组件上的ref属性在更新中被删除或更改，此字段会用于追踪需要清理的旧ref  // Props &amp; State  this.pendingProps = pendingProps; // 正在等待处理的新props  this.memoizedProps = null; // 上一次渲染时的props  this.updateQueue = null; // 一个队列，包含了该Fiber上的状态更新和副作用  this.memoizedState = null; // 上一次渲染时的state  this.dependencies = null; // 该Fiber订阅的上下文或其他资源的描述  // 工作模式  this.mode = mode; // 描述Fiber工作模式的标志（例如Concurrent模式、Blocking模式等）。  // Effects  this.flags = NoFlags; // 描述该Fiber发生的副作用的标志（十六进制的标识）  this.subtreeFlags = NoFlags; // 描述该Fiber子树中发生的副作用的标志（十六进制的标识）  this.deletions = null; // 在commit阶段要删除的子Fiber数组  this.lanes = NoLanes; // 与React的并发模式有关的调度概念。  this.childLanes = NoLanes; // 与React的并发模式有关的调度概念。  this.alternate = null; // Current Tree和Work-in-progress (WIP) Tree的互相指向对方tree里的对应单元  // 如果启用了性能分析  if (enableProfilerTimer) &#123;    // ……  &#125;  // 开发模式中  if (__DEV__) &#123;    // ……  &#125;&#125;\n\nFiber 工作原理Fiber 工作原理最核心的点就是可以中断和恢复, 增强了 react 的并发性和响应性\n工作原理中的几个关键点:\n\n单元工作: 每个 fiber 节点代表一个单元, 所有 fiber 节点构成一个 fiber 链表树, 使 react 可以细粒度控制节点行为\n链接属性: child, sibling, return 分别表示子节点, 兄弟节点和父节点, 构成了 fiber 之间的链接关系, 使 react 能够遍历 fiber 树来确定从哪里开始, 继续或停止工作\n双缓冲技术: react 在更新时会根据现有的 fiber 树 (current tree) 创建一个新的临时树 (work in progress (WIP) tree), WIP tree 包含了当前更新受影响的最高节点和其下所有子孙节点, WIP tree 在后台更新, current tree 则是显示在界面上的视图. WIP tree 更新完成后会复制其他节点并最终替换掉 current tree. 因为同时维护两个 fiber tree, 所以 react 可以随时进行比较, 中断或恢复等操作, 这种机制同时保证了渲染性能和 UI 稳定\nState &amp; props: memoizedProps, pendingProps, memoizedState 字段让 react 知道组件的上一个状态和即将应用的状态, 通过比较这些值, react 可以决定组件是否需要更新, 避免不必要的渲染\n副作用追踪: flags 和 subtreeFlags 标识 fiber 及其子树中需要执行的副作用, 如 DOM 更新, 生命周期调用等, react 会收集这些副作用, 在 commit 阶段一次性执行\n\nFiber 工作流程主要分为两个阶段:\nReconciliation 调和调和阶段确定了哪些部分的 UI 需要更新, 通过比较新的 props 和旧的 fiber 树来确定, 调和阶段可中断和恢复\n调和阶段分为两个小阶段:\n\n创建与标记更新节点: beginWork, 这个阶段会进行判断 fiber 是否需要更新, 以及判断 fiber 子节点是更新还是复用, 随后执行执行 fiber 节点的调和(处理诸如新 fiber 的创建, 旧 fiber 的删除或现有 fiber 的更新). beginWork 完成后就会进入 completeWork 流程\n收集副作用列表: completeUnitOfWork &amp; completeWork: completeUnitOfWork 负责遍历 fiber 节点, 同时记录有副作用的节点的关系, completeWork 在 completeUnitOfWork 中被调用, 主要用于记录 fiber 的副作用标志, 为子 fiber 创建链表以及根据 fiber 的 tag 进行不同的处理\n\nCommit 提交提交阶段会通过遍历在 Reconciliation 阶段创建的副作用列表来更新 DOM 并执行收集到的副作用, 提交阶段不可中断\n提交阶段分为三个小阶段:\n\n遍历副作用列表: commitBeforeMutationEffects, 遍历 fiber, 处理节点删除和确认节点在 before mutation 阶段是否有要处理的副作用\n正式提交: commitMutationEffects, 递归遍历 Fiber, 更新副作用节点\n处理 layout effects: commitLayoutEffects, 处理那些由 useLayoutEffect 创建的 layout effects\n\n","categories":["Web"],"tags":["React","Fiber"]}]